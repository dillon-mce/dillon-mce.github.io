<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Dev with Dillon</title><description>I'm Dillon and I like to code. I code for work, I code for fun, I read about code and I think about code. I share some of that code here and I do my best to share the lessons I learn along the way.</description><link>https://dillon-mce.com</link><language>en</language><lastBuildDate>Sun, 27 Feb 2022 08:01:46 -0700</lastBuildDate><pubDate>Sun, 27 Feb 2022 08:01:46 -0700</pubDate><ttl>250</ttl><atom:link href="https://dillon-mce.com/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">https://dillon-mce.com/posts/algorithms/intro</guid><title>Algorithms in Swift - Intro</title><description>In this post, I want to talk about algorithms in general, take a look at the binary search algorithm, and examine how to think about the complexity of an algorithm.</description><link>https://dillon-mce.com/posts/algorithms/intro</link><pubDate>Mon, 14 Jan 2019 12:00:00 -0700</pubDate><content:encoded><![CDATA[<p>I am looking for an excuse to learn more about algorithms, so I am going to write a series of posts that cover some of the most common ones and examine at what they might look like in Swift. I know algorithms often feel like an academic topic – something for nerds in computer science classes. They can be intimidating because their explanations and examples tend to be math-heavy and there is a lot of hard-to-decipher jargon out there about them. But they are really useful for solving interesting problems, and knowing how to pick the right algorithm for the problem at hand can make you seem like a programming genius! In this post, I want to talk about algorithms in general, take a look at the binary search algorithm, and examine how to think about the complexity of an algorithm.</p><h2>Algorithms</h2><p><a href="https://www.google.com/search?q=algorithm">If you search Google</a>, you’ll find that an algorithm is “a process or set of rules to be followed in calculations or other problem-solving operations, especially by a computer.” You use algorithms to search and to sort. You use algorithms to find the shortest route between two points, or to determine the next best move to take in a game. They are basically a set of instructions that you give to the computer that allows it to accomplish a task. And I know what you’re thinking, that is <em>all code</em>. And as far as I know, that is technically true. At least according to the definition given above. But when we talk about algorithms, we are usually talking about solving <em>interesting</em> problems. These are problems that seem easy for a human to do (with a small number of inputs at least) but whose solutions are not straightforward to describe in a way that computers can understand.</p><p>Algorithms tend to be described as <em>elegant</em> or <em>clever</em>. They don’t list out explicitly all the steps that a computer would use to solve the problem, they are distilled down descriptions of how to solve the problem. You and I are unlikely to ever come up with one that wasn’t already described by some computer science professor or medieval Muslim. <a href="https://en.wikipedia.org/wiki/Timeline_of_algorithms">Basically all of the good and useful ones have already been thought of</a>, so our job when it comes to algorithms tends to be <em>finding</em> the right one and <em>adapting</em> it to solve our particular problem. Even so, it is a helpful exercise to go through trying to come up with them for yourself, as it will help you remember the algorithms when the time comes that you need to implement them in real code.</p><h2>Binary Search</h2><p>Binary search is a relatively simple algorithm that can save <strong>huge</strong> amounts of time/calculations when you are searching against a large sorted list. Here is an example of what this algorithm might look like in real life (or at least what it would have looked like before we had digital dictionaries): Suppose you were reading an article or book and came across the word “obeliscolychny”. If you are like me, you probably wouldn’t know what that word means, and you would probably even have difficulty parsing out any meaning from the roots by just looking at it. So you, like any good reader, would pull out your dictionary and look up the word.</p><p>How would you go about doing that? Would you start at the first page and flip through them one at a time, scanning each page until you found the word? No! You would crack it open in the middle, check what letter you landed on, and move backwards if you had gone too far or forward if you had not gone far enough. You would quickly narrow down your scope until you found the word you were looking for. (It means “lighthouse” if you haven’t already Googled it.)</p><p>That’s how binary search works. It halves the number of possible elements with each step by checking the middle element. If it is too high, it can safely disregard all the elements above that element. If it is too low, it can safely disregard all the elements below that element. (This is why it only works if you are searching a sorted list.) It keeps doing that until finds the element it is looking for. Here is an example of what it might look like in Swift:</p><pre><code><span class="keyword">func</span> binarySearch&lt;T: <span class="type">Comparable</span>&gt;(<span class="keyword">_</span> array: [<span class="type">T</span>], <span class="keyword">for</span> element: <span class="type">T</span>) -&gt; <span class="type">Int</span>? {
    <span class="keyword">var</span> low = <span class="number">0</span>
    <span class="keyword">var</span> high = array.<span class="property">count</span> - <span class="number">1</span>

    <span class="keyword">while</span> low &lt;= <span class="call">high</span> {
        <span class="keyword">let</span> mid = (low + high) / <span class="number">2</span>
        <span class="keyword">let</span> guess = array[mid]

        <span class="keyword">if</span> guess == element { <span class="keyword">return</span> mid }
        <span class="keyword">if</span> guess &gt; element {
            high = mid - <span class="number">1</span>
        } <span class="keyword">else</span> {
            low = mid + <span class="number">1</span>
        }
    }
    <span class="keyword">return nil</span>
}
</code></pre><p>First, I make variables to keep track of the low and high spots to check against. Then I make a while loop that continues as long as <code>low</code> is less than or equal to <code>high</code> (meaning we still have elements to check). Each time through the loop, I get the midpoint between <code>low</code> and <code>high</code> and get the guess associated with that midpoint. If <code>guess</code> is the element we’re looking for, I return it. Otherwise, if <code>guess</code> is greater than the element we’re searching for (meaning it is too high) we set <code>high</code> equal to the current midpoint minus 1. If <code>guess</code> is less than the element (meaning it is too low) we set <code>low</code> equal to the current midpoint plus 1. If we get to the point were <code>low</code> is no longer less than or equal to <code>high</code>, it means the element doesn’t exist in this array, so I return nil.</p><p>In comparison, a “simple search” might look like this:</p><pre><code><span class="keyword">func</span> simpleSearch&lt;T: <span class="type">Equatable</span>&gt;(<span class="keyword">_</span> array: [<span class="type">T</span>], <span class="keyword">for</span> element: <span class="type">T</span>) -&gt; <span class="type">Int</span>? {    
    <span class="keyword">for</span> (index, item) <span class="keyword">in</span> array.<span class="call">enumerated</span>() {
        <span class="keyword">if</span> item == element { <span class="keyword">return</span> index }
    }
    <span class="keyword">return nil</span>
}
</code></pre><p>As you can see, it is much less code. Fewer places for errors. It just starts at the beginning and moves forward until it finds the element it is looking for. If it gets all the way through and doesn’t find it, it returns <code>nil</code>. It may be a better option, or at least it may not make a significant difference, if you know for certain that there will be a relatively small number of elements you are searching against.</p><p>To test these functions (and illustrate how many steps they take) I made a little list and searched for an element on it using both functions:</p><pre><code><span class="keyword">var</span> list: [<span class="type">Int</span>] = []
<span class="keyword">for</span> i <span class="keyword">in</span> <span class="call">stride</span>(from: <span class="number">1</span>, to: <span class="number">100</span>, by: <span class="number">2</span>) {
    list.<span class="call">append</span>(i)
}

<span class="call">binarySearch</span>(list, for: <span class="number">99</span>)
<span class="call">simpleSearch</span>(list, for: <span class="number">99</span>)
</code></pre><p>Then I added in a couple of helper variables and printed these results out to the console:</p><pre><code class="language-no-highlight">Binary search took 6 steps and completed in 3.898143768310547e-05 seconds.
Simple search took 50 steps and completed in 7.200241088867188e-05 seconds.
</code></pre><p>Binary search takes about 0.000039 seconds and simple search takes about 0.000072. With so few elements, binary search is only slightly faster in terms of time (and basically imperceptibly), but you can see that the number of steps is way lower with binary search. We’ll look at what a difference this can mean when you have way more inputs in the next section.</p><h2>Complexity</h2><p>If you were only looking at the times above, you might guess that simple search takes twice as long as binary search. So if we were to search a list of 500,000 elements instead of 50, however long binary search took, simple search would take twice as long. Let’s look at how long it actually takes:</p><pre><code class="language-no-highlight">Binary search took 19 steps and completed in 6.508827209472656e-05 seconds.
Simple search took 500000 steps and completed in 0.1531449556350708 seconds.
</code></pre><p>Binary search didn’t even double in the amount of time it takes (although the number of steps more than doubled, I’m assuming that a chunk of the time it takes has to do with setting up the objects in memory, not the actual calculations), but simple search takes more than 2000 times as long as it did the first time. You can also see that the number of steps necessary for simple search is <em>way</em> higher than binary. So it is not just that simple search takes longer than binary, but that the number of calculations it takes to complete (in the worst case) grows at a different rate as a function of the number of inputs.</p><p>Let’s break that down. In the first example above, simple search took 50 steps to find the last element in a list of 50 items. In the second example, it took 500,000 steps to find the last element in a list of 500,000 items. This means that the number of calculations required in the worst case is the same as the number of inputs given. The way you’ll see this described when talking about algorithms is its complexity or its speed or its running time and it is communicated with <a href="https://en.wikipedia.org/wiki/Big_O_notation">Big O notation</a> (insert sex joke here). The big O notation for simple search is <code>O(n)</code> because the number of calculations required is the same as the number of inputs (<code>n</code> stands for the number of inputs).</p><p>So what about Binary search? You don’t necessarily have to understand the math behind it, but since we are cutting the elements in half with each step, the number of calculations required in the worst case is log base2 of the number of inputs (rounded up to the nearest integer because you can’t have half a calculation). For instance log(50) is approximately 5.6 and so it took 6 steps when we had 50 items. log(500000) is about 18.9 and it took 19 steps when we had 500,000 items. So the big O notation for binary search is <code>O(log(n))</code>.</p><p>It is important to understand the complexity of the algorithm you are using if you are going to be calling it with more than a few inputs. Even algorithms with the worst complexity work ok with a small number of inputs, but many of them grow at a rate much faster than you might think. It is easy to write code that works with your sample data, but is totally unusable when it comes into contact with real-world data that is often a much larger set.</p><p>There are a few other common big O notations that you’ll see associated with algorithms:<code>O(1)</code>, <code>O(n * log(n))</code>, <code>O(n^2)</code>, <code>O(2^n)</code> and <code>O(n!)</code>. The best is <code>O(1)</code> or <em>constant time</em> which means that it takes the same amount of time no matter how many inputs there are. One example of this in Swift is checking whether an element is contained in a <code>Set</code>. The next is <code>O(log(n))</code> or <em>log time</em> which grows very slowly. Binary search is a good example of this. Next is <code>O(n)</code> or <em>linear time</em> which grows just as fast as the number of inputs. We saw this with simple search. Next is <code>O(n * log(n))</code> or <em>log-linear time</em>. A good example of this is a the quicksort algorithm (which I’ll cover in another post and link to here). Next is <code>O(n^2)</code> or <em>quadratic time</em>. An example of this is selection sort (again, I’ll link to this after I write about it). After that is <code>O(2^n)</code> or <em>exponential time</em>. One example of this is bogo sort (also known as permutation sort). Finally we have <code>O(n!)</code> or <em>factorial time</em>. An example of this is the algorithm to solve the <a href="https://en.wikipedia.org/wiki/Travelling_salesman_problem">traveling salesman problem</a>.</p><img src="https://dillon-mce.com/images/algorithms/Big-O-Graph.png" alt="Graph showing the growth rates of different complexities."/><h2>Wrap Up</h2><p>I hope this has been helpful. I know I learned a lot in writing it. Quick recap: - Algorithms are condensed descriptions of how to solve a particular problem, especially for computers. - Binary search is faster than simple search, but requires a sorted list and a little more code. - The complexity, or the rate of the number of necessary calculations as a function of the number of inputs, of a function can be described with big O notation.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://dillon-mce.com/posts/aoc2018/setup</guid><title>Advent of Code 2018 - Set up</title><description>The first (meta) problem with Advent of Code is to figure out how you’re going to organize your code for these challenges. How get the input into a usable format, how to keep things in order and minimize the time it takes, etc.</description><link>https://dillon-mce.com/posts/aoc2018/setup</link><pubDate>Mon, 10 Dec 2018 12:00:00 -0700</pubDate><content:encoded><![CDATA[<h3>Original Set up</h3><p>The first (meta) problem with Advent of Code is to figure out how you’re going to organize your code for these challenges. How get the input into a usable format, how to keep things in order and minimize the time it takes, etc.</p><p>At first, I decided to code my solutions in Swift in an Xcode playground. The organization I landed on for that was to make a blank source file and to declare a <code>public let day1Input: String</code> in there. I then set it to a multiline literal marked with <code>"""</code> on each end and pasted in the input given.</p><p>In my playground page I defined a function called something relevant like <code>calculateFrequency(_ string: String) -&gt; Int</code>, added a constant <code>let testData = "+1, -2, +3, +1"</code> for my tests and then called <code>calculateFrequency(testData)</code> while I was writing the function and <code>calculateFrequency(day1Input)</code> when I was ready to get my answer. As I went through the days I would typically write the function to return the answer value, but as I went on (and the number of computations for each function went up) I found that it would print the answer way faster than the playgrounds interface would catch up and show the returned answer, so I started printing it as well.</p><h3>Current Setup</h3><p>Around day 9 I ran into a wall with playgrounds. It was eating memory at an unbelievable rate and taking <strong>way too long</strong> to calculate. That is when I started looking for other options.</p><p>I am only tentatively comfortable with the command line, but I tried just running <code>swift Day-9.swift</code> in Terminal and found that it worked. It compiled and ran (much faster than the playground) and printed the print statements out to the terminal. I’m sure that probably sound obvious to you CLI experts, but I don’t really know how that stuff works. So it was cool to see.</p><p>My hurdle then was getting the input data passed to the file. I tried just putting it all into the same file, but some of the inputs are really long and because of the way it compiles, you have to put the constant above where you call the function with it, which was just ugly. (I’m sure there’s a flag you can add to the <code>swift</code> command that would fix that, but I couldn’t figure it out, so I moved on.) After some googling, I found that you can get a reference to the command line arguments inside of the Swift file with “CommandLine.arguments”, the first argument being the file itself and the second being whatever is passed in. So I could save my input data in a separate file and run the code by calling <code>swift Day-1.swift "$(cat Day-1-Input.txt)"</code>. Problem solved!</p><h3>Getting Into Swift Scripting</h3><p>That is when I started down the rabbit hole of scipting with Swift. My first discovery was that you can add a shebang to the beginning of the file and run it as it’s own script. For swift it is <code>#!/usr/bin/swift</code>. You also need to modify the permissions with <code>chmod +x Day-1.swift</code> then all you need to run it is to type <code>./Day-1.swift "$(cat Day-1-Input.txt)"</code> into Terminal. That was a lot better, but it still involved a lot of typing and relied on my typing everything exactly right.</p><p>So I decided to see if I could write a simple bash script that would run this command for me. After reading through <a href="http://linuxcommand.org/lc3_writing_shell_scripts.php">this very helpful website about shell scripts</a>, I added a script called “adventofcode” to my <code>usr/local/bin</code> directory (I don’t know if that is the right place to put these things, but it seems to work.) I declared it as a bash script with <code>#!/bin/bash</code> and wrote:</p><pre><code><span class="keyword">if</span> [ $1 != <span class="string">""</span>]; then
	./<span class="type">Day</span>-$1.<span class="property">swift</span> <span class="string">"$(cat. Day-$1-Input.txt)"</span>
	exit <span class="number">0</span>
<span class="keyword">else</span>
	echo <span class="string">"You need to pass in a number parameter"</span>
	exit <span class="number">1</span>
fi
</code></pre><p>This basically says, if we’re given an input, try to call that long and messy swift script with the associated input data. Otherwise, tell the user they are doing it wrong.</p><p>Of course, I had to modify the permissions on this new adventofcode script as well, but after I did, it works exactly as I had hoped. (One thing to note is that it is using a relative path to the Swift script, so it only works if you call it from the directory where that Swift script lives.)</p><p>I quickly realized that during testing I would want to call my script without passing input data so I added a case statement to my bash script so that it looked like this:</p><pre><code><span class="keyword">if</span> [ <span class="string">"$1"</span> != <span class="string">""</span> ]; then
  <span class="keyword">case</span> $1 <span class="keyword">in</span>
    -t | --test )   <span class="keyword">if</span> [ <span class="string">"$2"</span> != <span class="string">""</span> ]; then
                      ./<span class="type">Day</span>-$2.<span class="property">swift</span>
                      exit <span class="number">0</span>
                    <span class="keyword">else</span>
                      echo <span class="string">"You need to pass in a number parameter"</span>
                      exit <span class="number">1</span>
                    fi
                    ;;
    * )             ./<span class="type">Day</span>-$1.<span class="property">swift</span> <span class="string">"$(cat Day-$1-Input.txt)"</span>
                    exit <span class="number">0</span>
  esac
<span class="keyword">else</span>
  echo <span class="string">"You need to pass in a number parameter"</span>
  exit <span class="number">1</span>
fi
</code></pre><p>This says, if I call adventofcode with a <code>-t</code> or <code>--test</code> flag, it will run the script with no input, otherwise it will run it with the associated input. (Again, I know very little about bash, so there is probably a better way to organize this.)</p><h3>Cleaning Things Up</h3><p>Now I had a nice (and relatively pretty) way to run my code once I had something to run. But I found as I was moving things over to individual Swift files that I generally wanted the same structure for each of these files: - I wanted to declare it as a Swift script - I wanted to import Cocoa - I wanted to set my inputData as the command line argument or an empty string - I wanted some code up top that gave me a header/reference point for the stuff printing out to the console. - I wanted an area to put my code for part 1 - I wanted an area to do some testing for part 1 - I wanted the same for part 2 - And then at the bottom I wanted a function to run both parts and log the time it took.</p><p>So I pulled out all of those pieces and made an <code>_template.swift</code> file. Then, when I was ready to start a new day I ran this series of commands: - <code>cp _template.swift Day-13.swift</code> - <code>chmod +x Day-13.swift</code> - <code>touch Day-13-Input.txt</code></p><p>After running all those commands once, I realized I could probably just add it to my adventofcode script. So I added a <code>-n</code> or <code>--new</code> case to my script that looks like this:</p><pre><code>-n | --new )   <span class="keyword">if</span> [ <span class="string">"$2"</span> != <span class="string">""</span> ]; then
                 cp -n _template.<span class="property">swift</span> <span class="type">Day</span>-$2.<span class="property">swift</span>
                 chmod +x <span class="type">Day</span>-$2.<span class="property">swift</span>
                 touch <span class="type">Day</span>-$2-<span class="type">Input</span>.<span class="property">txt</span>
                 exit <span class="number">0</span>
               <span class="keyword">else</span>
                 echo <span class="string">"You need to pass in a number parameter"</span>
                 exit <span class="number">1</span>
               fi
               ;;
</code></pre><p>This makes both files for me and modifies the permissions, and all I have to do is type <code>adventofcode -n</code> and a number. I added the -n flag to cp because then it will only copy if the file you’re copying to doesn’t already exist. That let me run this same script if I already had my swift file for the day, but needed to add the input file or modify the permissions. It also makes it safer if I accidentally run it on a day that I already have code for.</p><p>After all that, I have a pretty solid little set up that lets me start coding quickly and makes my life easier without getting in the way.</p><p>You can find my full adventofcode script, my template file and all of my attempts so far in <a href="https://github.com/dillon-mce/advent-of-code-2018">my advent of code 2018 repository on GitHub</a>.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://dillon-mce.com/posts/aoc2018/day7</guid><title>Advent of Code 2018 - Day 7</title><description>My understanding of Day 7’s first problem is this: given a  series of instructions like the one below, return a String which is the correct order in which the instructions will be executed.</description><link>https://dillon-mce.com/posts/aoc2018/day7</link><pubDate>Sat, 8 Dec 2018 12:00:00 -0700</pubDate><content:encoded><![CDATA[<h2><a href="https://adventofcode.com/2018/day/7">Problem 1</a></h2><p>My understanding of Day 7’s first problem is this: given a series of instructions like the one below, return a String which is the correct order in which the instructions will be executed. The sample data returns <code>"CABDFE"</code>.</p><pre><code><span class="type">Step C</span> must be finished before step <span class="type">A</span> can begin.
<span class="type">Step C</span> must be finished before step <span class="type">F</span> can begin.
<span class="type">Step A</span> must be finished before step <span class="type">B</span> can begin.
<span class="type">Step A</span> must be finished before step <span class="type">D</span> can begin.
<span class="type">Step B</span> must be finished before step <span class="type">E</span> can begin.
<span class="type">Step D</span> must be finished before step <span class="type">E</span> can begin.
<span class="type">Step F</span> must be finished before step <span class="type">E</span> can begin.
</code></pre><h3>Method</h3><p>My method for solving this problem looks like this: - Parse the input into a dictionary which holds steps that are dependent on others as the key and an array of the steps they are dependent as the value, and an array of all the steps that need to be executed, sorted alphabetically. - Make a set to hold the steps which are completed, and an array to hold the order all the steps in the order they are completed. - Using a similar method to <a href="{{"/Advent-of-Code-2018-Day-5" | absolute_url}}">the collapsing polymer problem</a>, loop through a while loop until the letter array is empty.	- Inside of that outer loop, loop through the array until a step that can be executed is found.	- Execute that step. Insert it into the set of completed steps, append it to the results array, and remove it from the letter array. - After the while loop, return the results array joined into a string.</p><h3>Implementation</h3><p>My <code>parseInput()</code> function looks like this:</p><pre><code><span class="keyword">func</span> parseInput(<span class="keyword">_</span> string: <span class="type">String</span>) -&gt; ([<span class="type">String</span>: [<span class="type">String</span>]], [<span class="type">String</span>]) {
    <span class="keyword">let</span> array = string.<span class="call">components</span>(separatedBy: .<span class="dotAccess">newlines</span>))
    <span class="keyword">var</span> dependencyDict: [<span class="type">String</span>: [<span class="type">String</span>]] = [:]
    <span class="keyword">var</span> letterSet: <span class="type">Set</span>&lt;<span class="type">String</span>&gt; = <span class="type">Set</span>()
    <span class="keyword">for</span> line <span class="keyword">in</span> array {
        <span class="keyword">let</span> letters = line.<span class="call">components</span>(separatedBy: .<span class="dotAccess">whitespaces</span>).<span class="call">filter</span>() { $0.<span class="property">count</span> == <span class="number">1</span> }
        dependencyDict[letters[<span class="number">1</span>], <span class="keyword">default</span>: []].<span class="call">append</span>(letters[<span class="number">0</span>])
        letterSet.<span class="call">insert</span>(letters[<span class="number">0</span>])
        letterSet.<span class="call">insert</span>(letters[<span class="number">1</span>])
    }
    <span class="keyword">let</span> letterArray = <span class="type">Array</span>(letterSet).<span class="call">sorted</span>()
    <span class="keyword">return</span> (dependencyDict, letterArray)
}
</code></pre><p>First, I break the string into an array split on newlines. Then I set up a dictionary to hold the steps that are dependent and an array of the steps they are dependent on and a set to hold all of the steps that need to be executed. Then I loop through each line in the array, break it up by splitting on whitespaces and filtering for single character elements. I add the dependency to the dependency dict and make sure both letters are in the letter set. At the end I make an array from the letter set, sort it, and then return a tuple of the dependency dictionary and a letter array.</p><p>My main function for part 1 looks like this:</p><pre><code><span class="keyword">func</span> figureOutOrder(<span class="keyword">_</span> string: <span class="type">String</span>) -&gt; <span class="type">String</span> {
    <span class="keyword">var</span> (dependencyDict, letterArray) = <span class="call">parseInput</span>(string)

    <span class="keyword">var</span> completedSet: <span class="type">Set</span>&lt;<span class="type">String</span>&gt; = <span class="type">Set</span>()
    <span class="keyword">var</span> results: [<span class="type">String</span>] = []
    <span class="keyword">while</span> letterArray.<span class="property">count</span> &gt; <span class="number">0</span> {
        <span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">0</span>..&lt;letterArray.<span class="property">count</span> {
            <span class="keyword">let</span> letter = letterArray[index]
            <span class="keyword">let</span> dependencies = dependencyDict[letter]?.<span class="call">filter</span>() { !completedSet.<span class="call">contains</span>($0) }
            <span class="keyword">if</span> dependencies == <span class="keyword">nil</span> || dependencies == [] {
                completedSet.<span class="call">insert</span>(letter)
                results.<span class="call">append</span>(letter)
                letterArray.<span class="call">remove</span>(at: index)
                <span class="keyword">break</span>
            }
        }
    }
    <span class="keyword">return</span> results.<span class="call">joined</span>()
}
</code></pre><p>First, I get my dependency dictionary and letter array by calling <code>parseInput()</code> and set up variables to hold the completed steps and the resulting order. Then, inside a while loop that will continue until the letter array is empty, loop through the letter array until a letter is found that has no dependencies or, all of whose dependencies have been completed. Once one is found, I insert it into the completed set, add it to the results array, remove it from the letter array and break out of the current loop. Restarting from the beginning of the array every time a step is completed insures that if two steps could be completed at the same time, they will be completed in alphabetical order, as stipulated in the directions. Once the while loop completes, return the results array <code>.joined()</code></p><p>The answer for my input was <code>"CHILFNMORYKGAQXUVBZPSJWDET"</code> and it takes about 2 milliseconds to find using the command line method described in <a href="{{"/Advent-of-Code-2018-Setup" | absolute_url}}">my AoC setup post</a>.</p><h2><a href="https://adventofcode.com/2018/day/7#part2">Problem 2</a></h2><p>I would describe the second problem like this: given the same set of instructions before, assuming that each step takes 60 seconds plus the letter’s index (e.g. A=61, B=62, Z=86) and assuming that there are up to five workers working on concurrent steps, return an Int which is how many seconds it will take to complete all the instructions.</p><h3>Method</h3><p>How I solved this problem: - Write a helper function to build a dictionary of how long each step will take. - Add a custom Queue struct to represent a worker.	- Has a private array to hold its work	- A computed property which is the step it is currently working on (optional)	- A function to push a new step onto the queue, a given number of times	- A function to pop an element off of the queue - Use the same <code>parseInput()</code> method to get a dependency dictionary and letter array, use the helper function to get a dictionary of letter values, set up an array of Queues to hold the workers based on the number passed into the function, make a set to hold completed steps, a set to hold steps being worked on, and an Int variable to hold the resulting number of seconds. - Similar to part 1, make a while loop that will continue until the letter array is empty. - The while loop will have two sections, the first will cycle through the queues and complete one “second” of each of their work and update the letter array if any of them finish. The second part will loop through all the remaining letters, try to find one with no dependencies, and if there are any open queues, add it to that queue. - Each cycle through the while loop will add one second to the result “timer”</p><h3>Implementation</h3><p>My helper function to set up the dictionary of letter values looks like this:</p><pre><code><span class="keyword">func</span> setupLetterValueDictionary(<span class="keyword">_</span> offset: <span class="type">Int</span>) -&gt; [<span class="type">String</span>: <span class="type">Int</span>] {
    <span class="keyword">let</span> alphabet = <span class="string">"abcdefghijklmnopqrstuvwxyz"</span>.<span class="call">uppercased</span>()
    <span class="keyword">var</span> value = <span class="number">1</span> + offset
    <span class="keyword">var</span> result: [<span class="type">String</span>: <span class="type">Int</span>] = [:]
    <span class="keyword">for</span> letter <span class="keyword">in</span> alphabet {
        result[<span class="type">String</span>(letter)] = value
        value += <span class="number">1</span>
    }
    <span class="keyword">return</span> result
}
</code></pre><p>Nothing very interesting, it just loops through the alphabet and adds the associated value to a dictionary at the key for each letter.</p><p>My custom Queue looks like this:</p><pre><code><span class="keyword">class</span> Queue&lt;T&gt; {
    <span class="keyword">private var</span> queue: [<span class="type">T</span>] = []

    <span class="keyword">var</span> currentlyWorkingOn: <span class="type">T</span>? {
        <span class="keyword">return</span> queue.<span class="property">first</span>
    }

    <span class="keyword">func</span> push(<span class="keyword">_</span> string: <span class="type">T</span>, times: <span class="type">Int</span>) {
        <span class="keyword">for _ in</span> <span class="number">0</span>..&lt;times {
            queue.<span class="call">append</span>(string)
        }
    }

    <span class="keyword">func</span> pop() {
        <span class="keyword">if</span> queue.<span class="property">count</span> &gt; <span class="number">0</span> {
            queue.<span class="call">remove</span>(at: <span class="number">0</span>)
        }
    }
}
</code></pre><p>It is generic, mostly in case I need to reuse it in future code challenges. It has a private queue which is held in an array. It has a computed property which returns an optional element that is the first element of the queue or nil if it is empty. It has a function to push a new element onto the queue a given number of times, and it has a function to pop the first element off the queue. I did not return the element that is popped, because it isn’t necessary here.</p><p>The setup section of my main function looks like this:</p><pre><code><span class="keyword">var</span> (dependencyDict, letterArray) = <span class="call">parseInput</span>(string)
<span class="keyword">let</span> letterValueDict = <span class="call">setupLetterValueDictionary</span>(timeAddition)
<span class="keyword">var</span> queues: [<span class="type">Queue</span>&lt;<span class="type">String</span>&gt;] = []
<span class="keyword">for _ in</span> <span class="number">0</span>..&lt;numOfWorkers {
    queues.<span class="call">append</span>(<span class="type">Queue</span>())
}
<span class="keyword">var</span> completedSet: <span class="type">Set</span>&lt;<span class="type">String</span>&gt; = <span class="type">Set</span>()
<span class="keyword">var</span> currentlyWorkingOn: <span class="type">Set</span>&lt;<span class="type">String</span>&gt; = <span class="type">Set</span>()
<span class="keyword">var</span> result: <span class="type">Int</span> = <span class="number">0</span>
</code></pre><p>I get the dependency dictionary and letter array by calling <code>parseInput()</code>, I get the letter values by calling <code>setupLetterValueDictionary()</code>, and I set up an array of queues to which I add as many queues as are called for when the function is called. I also make a set to hold the completed steps, a set to hold the steps that are being worked on, and a variable to hold the resulting number of seconds.</p><p>The first part of the while loop in the main function looks like this:</p><pre><code><span class="keyword">while</span> letterArray.<span class="property">count</span> &gt; <span class="number">0</span> {
        <span class="keyword">for</span> queue <span class="keyword">in</span> queues {
            <span class="keyword">let</span> previouslyWorking = queue.<span class="property">currentlyWorkingOn</span>
            queue.<span class="call">pop</span>()
            <span class="keyword">if</span> previouslyWorking != queue.<span class="property">currentlyWorkingOn</span> {
                <span class="keyword">if let</span> previouslyWorking = previouslyWorking {
                    completedSet.<span class="call">insert</span>(previouslyWorking)
                }
            }
        }
        letterArray = letterArray.<span class="call">filter</span>() { !completedSet.<span class="call">contains</span>( $0 ) }
        <span class="keyword">if</span> letterArray.<span class="property">count</span> == <span class="number">0</span> { <span class="keyword">break</span> }
</code></pre><p>I loop through each queue, grab a reference to what it was working on, and then pop the first element. Then I check to see if the previous element is not the same as the current element. Because we are only adding one step to each queue at a time, we know that the only time they would be different is if we had some step in the queue and now we don’t. That means we’ve finished that step, so we’ll insert it into the set of completed letters. Then we filter the letter array to only have the letters that haven’t been completed and check to see if it is empty. If it is, that means we’re done and we break out of the loop.</p><p>The second half of the while loop looks like this:</p><pre><code>     <span class="keyword">for</span> letter <span class="keyword">in</span> letterArray {
            <span class="keyword">let</span> dependencies = dependencyDict[letter]?.<span class="call">filter</span>() { !completedSet.<span class="call">contains</span>( $0 ) }
            <span class="keyword">if</span> (dependencies == <span class="keyword">nil</span> || dependencies == []) &amp;&amp; !currentlyWorkingOn.<span class="call">contains</span>(letter) {
                <span class="keyword">for</span> queue <span class="keyword">in</span> queues {
                    <span class="keyword">if</span> queue.<span class="property">currentlyWorkingOn</span> == <span class="keyword">nil</span> {
                        <span class="keyword">let</span> times = letterValueDict[letter]!
                        queue.<span class="call">push</span>(letter, times: times)
                        currentlyWorkingOn.<span class="call">insert</span>(letter)
                        <span class="keyword">break</span>
                    }
                }
            }
        }
        result += <span class="number">1</span>
    }
</code></pre><p>Here we first loop through the letters left in the letterArray, try to find one that doesn’t have any dependencies or all of whose dependencies have been completed, and that isn’t already being worked on by some other queue. If we find one, we’ll loop through all the queues and try to find one that isn’t already working on something. If we find one, we get the number of seconds that step will take to complete from the dictionary, push it onto the queue, insert it into the set of steps currently being worked on, and break out of this loop through the queues. At the end of each pass through the while loop, we add one to the resulting seconds. And after the while loop completes, return the result</p><p>The answer for my input is <code>891</code> with 5 workers and a 60 second offset. It takes about 45 milliseconds to calculate on the command line.</p><h2>Reflections</h2><ul><li>This problem gave me some good practice with using Sets and Dictionaries.</li><li>It also forced me to figure out a way to work out queues/concurrency with a possible different number of tasks being worked on at the same time.</li><li>It also gave me the opportunity to figure out how to simulate the passage of time.</li></ul><p>You can find all the code for my attempts so far in <a href="https://github.com/dillon-mce/advent-of-code-2018">my advent of code 2018 repository on GitHub</a>.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://dillon-mce.com/posts/aoc2018/day6</guid><title>Advent of Code 2018 - Day 6</title><description>My understanding of Day 6’s first problem is this: given a list of coordinates like the one below, return an Int which is the size of the largest open area that isn’t infinite (using Manhattan or taxicab distance) around a point.</description><link>https://dillon-mce.com/posts/aoc2018/day6</link><pubDate>Fri, 7 Dec 2018 12:00:00 -0700</pubDate><content:encoded><![CDATA[<h2><a href="https://adventofcode.com/2018/day/6">Problem 1</a></h2><p>My understanding of Day 6’s first problem is this: given a list of coordinates like the one below, return an Int which is the size of the largest open area that isn’t infinite (using Manhattan or taxicab distance) around a point. The sample data returns 17.</p><pre><code><span class="number">1</span>, <span class="number">1
1</span>, <span class="number">6
8</span>, <span class="number">3
3</span>, <span class="number">4
5</span>, <span class="number">5
8</span>, <span class="number">9</span>
</code></pre><h3>Method</h3><p>My method for solving this problem looks like this: - Make a Point struct that has an X and Y coordinate and a method to calculate its distance from another point. - Break the input into an array, and make an array of points out of it. - Figure out the smallest and largest X and Y. These will be our bounds. - Make an <code>areaDict</code> dictionary to hold the points we are given in the input as keys, and array’s of the points that belong to them as the values. - Cycle through all the Xs and Ys from the smallest to the largest of each	- Make another dictionary that holds each point given in the input as keys, and its distance from the current point as values	- Populate that dictionary with the distances	- Find the smallest distance, and if there is only one, add the point to the <code>areaDict</code> dictionary - Filter the area dictionary to get rid of any that point that has values which touch the bounds. Those are infinite. - Find the biggest value in the filtered dictionary and return the count of its points.</p><h3>Implementation</h3><p>My <code>Point</code> struct looks like this:</p><pre><code><span class="keyword">struct</span> Point: <span class="type">Hashable</span> {
    <span class="keyword">var</span> x: <span class="type">Int</span>
    <span class="keyword">var</span> y: <span class="type">Int</span>

    <span class="keyword">func</span> calculateDistance(from point: <span class="type">Point</span>) -&gt; <span class="type">Int</span> {
        <span class="keyword">return</span> <span class="call">abs</span>(<span class="keyword">self</span>.<span class="property">x</span> - point.<span class="property">x</span>) + <span class="call">abs</span>(<span class="keyword">self</span>.<span class="property">y</span> - point.<span class="property">y</span>)
    }
}
</code></pre><p>It is Hashable so that I can make it the key in a dictionary, and it has variables for the X value and the Y value of the point. <code>calculateDistance()</code> takes a point and calculates the Manhattan or taxicab distance from the point. The equation for that is the absolute value of X1 - X2 plus the absolute value of Y1 - Y2. You can read more about it in <a href="https://en.wikipedia.org/wiki/Taxicab_geometry">this Wikipedia article</a> .</p><p>My <code>parseInput()</code> function looks like this:</p><pre><code><span class="keyword">func</span> parseInput(<span class="keyword">_</span> string: <span class="type">String</span>) -&gt; [<span class="type">Point</span>] {
    <span class="keyword">let</span> array = string.<span class="call">components</span>(separatedBy: <span class="type">CharacterSet</span>(charactersIn: <span class="string">"\n"</span>))

    <span class="keyword">let</span> pointArray = array.<span class="call">compactMap</span>() { string -&gt; <span class="type">Point</span>? <span class="keyword">in
        let</span> array = string.<span class="call">components</span>(separatedBy: .<span class="dotAccess">punctuationCharacters</span>).<span class="call">joined</span>().<span class="call">components</span>(separatedBy: .<span class="dotAccess">whitespaces</span>)
        <span class="keyword">guard</span> array.<span class="property">count</span> &gt; <span class="number">1</span>, <span class="keyword">let</span> x = <span class="type">Int</span>(array[<span class="number">0</span>]), <span class="keyword">let</span> y = <span class="type">Int</span>(array[<span class="number">1</span>]) <span class="keyword">else</span> { <span class="keyword">return nil</span> }
        <span class="keyword">let</span> point = <span class="type">Point</span>(x: x, y: y)
        <span class="keyword">return</span> point
    }

    <span class="keyword">return</span> pointArray
}
</code></pre><p>I first split up the input string into an array of each line and then I make an array of Points by calling <code>compactMap()</code> on that array. Inside of the closure, I try to pull out the X and Y values and make Ints out of them, if that doesn’t work, I just skip that line by returning nil. This works here because the input data is perfectly uniform. If I am able to get the values, I make a Point out of them and return it.</p><p>The first part of my main function looks like this:</p><pre><code><span class="keyword">let</span> pointArray = <span class="call">parseInput</span>(string)

<span class="keyword">guard let</span> maxX = pointArray.<span class="call">max</span>(by: { $0.<span class="property">x</span> &lt; $1.<span class="property">x</span> }), <span class="keyword">let</span> maxY = pointArray.<span class="call">max</span>(by: { $0.<span class="property">y</span> &lt; $1.<span class="property">y</span> }), <span class="keyword">let</span> minX = pointArray.<span class="call">min</span>(by: { $0.<span class="property">x</span> &lt; $1.<span class="property">x</span> }), <span class="keyword">let</span> minY = pointArray.<span class="call">min</span>(by: { $0.<span class="property">y</span> &lt; $1.<span class="property">y</span> }) <span class="keyword">else</span> { <span class="keyword">return</span> -<span class="number">1</span> }
</code></pre><p>I get an array of Points by calling the <code>parseInput()</code> function. After that, I pull out the smallest and largest X, and the smallest and largest Y. That gives me the bounds of the grid that we care about.</p><p>The main part of the function looks like this:</p><pre><code><span class="keyword">var</span> areaDict: [<span class="type">Point</span>: [<span class="type">Point</span>]] = [:]
<span class="keyword">for</span> x <span class="keyword">in</span> minX.<span class="property">x</span>...maxX.<span class="property">x</span> {
    <span class="keyword">for</span> y <span class="keyword">in</span> minY.<span class="property">y</span>...maxY.<span class="property">y</span> {
        <span class="keyword">var</span> distanceDict: [<span class="type">Point</span>: <span class="type">Int</span>] = [:]
        <span class="keyword">let</span> testPoint = <span class="type">Point</span>(x: x, y: y)
        <span class="keyword">for</span> point <span class="keyword">in</span> pointArray {
                distanceDict[point] = point.<span class="call">calculateDistance</span>(from: testPoint)
        }
        <span class="keyword">if let</span> min = distanceDict.<span class="call">min</span>(by: { $0.<span class="property">value</span> &lt; $1.<span class="property">value</span> }) {
            <span class="keyword">if</span> distanceDict.<span class="property">values</span>.<span class="call">filter</span>({ $0 == min.<span class="property">value</span> }).<span class="property">count</span> == <span class="number">1</span> {
                areaDict[min.<span class="property">key</span>, default: []].<span class="call">append</span>(testPoint)
            }
        }
    }
}
</code></pre><p>First, I make a dictionary to hold each point from the input data, and an array of points that it is closest to. Then I loop through all of the Xs and Ys that we care about (the ones inside the bounds), make a Point out of each, and a dictionary to hold its distance to each of the input points. Then I calculate the distance to each of the input points and store them in that dictionary. Finally, I find the smallest distance in that dictionary and if there is only one Point that is that distance, add the Point we’re currently checking to the array in the <code>areaDict</code> at the Point it is closest to.</p><p>Finally, after populating the <code>areaDict</code>, the rest of the function looks like this:</p><pre><code><span class="keyword">let</span> filteredDict = areaDict.<span class="call">filter</span> { (key: <span class="type">Point</span>, value: [<span class="type">Point</span>]) -&gt; <span class="type">Bool</span> <span class="keyword">in
        let</span> array = value.<span class="call">filter</span>() {
            <span class="keyword">return</span> $0.<span class="property">x</span> == minX.<span class="property">x</span> || $0.<span class="property">x</span> == maxX.<span class="property">x</span> || $0.<span class="property">y</span> == minY.<span class="property">y</span> || $0.<span class="property">y</span> == maxY.<span class="property">y</span>
        }
        <span class="keyword">return</span> !(array.<span class="property">count</span> &gt; <span class="number">0</span>)
    }

    <span class="keyword">let</span> biggestArea = filteredDict.<span class="call">max</span>(by: { $0.<span class="property">value</span>.<span class="property">count</span> &lt; $1.<span class="property">value</span>.<span class="property">count</span> })

<span class="keyword">return</span> biggestArea?.<span class="property">value</span>.<span class="property">count</span> ?? -<span class="number">1</span>
</code></pre><p>I get a new dictionary which is <code>areaDict</code> filtered of all the input Points that have any closest Points that touch the bounds, because that means they are infinite on this grid. I then find the input Point that has the largest count of points (i.e. area) and then return that value. I use the nil coalescing operator because <code>biggestArea</code> is optional, and that was the easiest/ fastest way to unwrap it. I return -1 as the default because that will never be a value the function should produce so it will be a sign to me that something has gone wrong.</p><p>The answer for my input was <code>4398</code> and it takes about 3.5 seconds to calculate on the command line using the method described in <a href="{{"/Advent-of-Code-2018-Setup" | absolute_url}}">my AoC Setup post</a>.</p><h2><a href="https://adventofcode.com/2018/day/6#part2">Problem 2</a></h2><p>I would describe the second problem like this: given the same list of coordinates, return an Int which is the total area in which each Point’s distance from all of the given coordinates adds up to something less than a given target value. The sample data returns 16 with a target value of 32.</p><h3>Method</h3><p>This is how I solved this problem: - Get an array of Points and find the bounds the same as before. - Make a Set of Points that will hold all of the “safe points” - Cycle through each X and Y within the bounds and check if they are “safe” by adding up its distances from each of the input Points. - If they are safe, add them to the set. - Return the count of safe points.</p><h3>Implementation</h3><p>I used the same <code>Point</code> and <code>parseInput()</code> function as before, and the first few lines of my main function for this part is identical to the main function from the first part, except that I wrote this function to take in a <code>targetValue</code> which is an Int, so that I could test against the sample data and my input data with different target values.</p><p>The section that is different looks like this:</p><pre><code><span class="keyword">var</span> safePoints: <span class="type">Set</span>&lt;<span class="type">Point</span>&gt; = <span class="type">Set</span>()
<span class="keyword">for</span> x <span class="keyword">in</span> minX.<span class="property">x</span>...maxX.<span class="property">x</span> {
    <span class="keyword">for</span> y <span class="keyword">in</span> minY.<span class="property">y</span>...maxY.<span class="property">y</span> {
        <span class="keyword">var</span> distanceDict: [<span class="type">Point</span>: <span class="type">Int</span>] = [:]
        <span class="keyword">let</span> testPoint = <span class="type">Point</span>(x: x, y: y)
        <span class="keyword">for</span> point <span class="keyword">in</span> pointArray {
            distanceDict[point] = point.<span class="call">calculateDistance</span>(from: testPoint)
        }
        <span class="keyword">let</span> sum = distanceDict.<span class="property">values</span>.<span class="call">reduce</span>(<span class="number">0</span>, +)
        <span class="keyword">if</span> sum &lt; targetValue {
            safePoints.<span class="call">insert</span>(testPoint)
        }
    }
}

<span class="keyword">return</span> safePoints.<span class="property">count</span>
</code></pre><p>First, I make a Set to hold the safe points and set it to an empty Set. Then I loop through all the Xs and Ys in the bounds, make a Point out of each one and a dictionary to hold the distances from each of the input Points. Then I just reduce that dictionary to a single value and if it is less than the <code>targetValue</code> I insert the point into the <code>safePoints</code> set. At the end, I return the count of points.</p><p>The answer for my input with a target value of 10,000 is <code>39560</code> and it takes about 2.5 seconds to calculate on the command line.</p><h2>Reflections</h2><ul><li>This was another interesting geometrical problem. Lots of practice keeping track of and comparing coordinates.</li><li>It also forced me to think a little abstractly about the bounds to the grid and how to tell if a certain point was closest to an infinite number of points or not.</li></ul><p>You can find all the code for my attempts so far in <a href="https://github.com/dillon-mce/advent-of-code-2018">my advent of code 2018 repository on GitHub</a>.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://dillon-mce.com/posts/aoc2018/day5</guid><title>Advent of Code 2018 - Day 5</title><description>My understanding of Day 5’s first problem is this: given a String like "dabAcCaCBAcCcaDA", return an Int which is the number of characters remaining after being reduced by removing pairs of letters which are adjacent, the same letter, and opposite cases.</description><link>https://dillon-mce.com/posts/aoc2018/day5</link><pubDate>Thu, 6 Dec 2018 12:00:00 -0700</pubDate><content:encoded><![CDATA[<h2><a href="https://adventofcode.com/2018/day/5">Problem 1</a></h2><p>My understanding of Day 5’s first problem is this: given a String like <code>"dabAcCaCBAcCcaDA"</code>, return an Int which is the number of characters remaining after being reduced by removing pairs of letters which are adjacent, the same letter, and opposite cases. For example <code>"cC"</code> and <code>"Aa"</code>. The sample returns 10.</p><h3>Method</h3><p>My method for solving this problem looks like this: - Make an outer while loop that will continue until you make it all the way through the String without finding any pairs that can be removed. - Inside of the while loop, loop through all the letters in the String except the last, and check the current character against the next one. - If the current letter doesn’t equal the next letter, but if the lowercased versions of each of them are equal, it means they meet the criteria for removal.	- Remove them	- Update our start index for the next time through the for loop	- Break out of the current loop. - We need to check the letter before the ones we just removed, because it may have been affected by the removal. But we only need to go back one letter, we don’t need to check the whole preceding String again. - If they don’t match and the current index equals the second to last element, that means we have made it all the way through the String successfully, so update that Bool and end the while loop. - Finally, return the resulting String.</p><h3>Implementation</h3><p>My <code>collapsePolymer()</code> function for the first part looks like this:</p><pre><code><span class="keyword">func</span> collapsePolymer(<span class="keyword">_</span> string: <span class="type">String</span>) -&gt; <span class="type">String</span> {
    <span class="keyword">var</span> array = <span class="type">Array</span>(string)
    <span class="keyword">var</span> madeFullPass = <span class="keyword">false
    var</span> madeToIndex = <span class="number">0</span>

    <span class="keyword">while</span> !<span class="call">madeFullPass</span> {
        <span class="keyword">for</span> i <span class="keyword">in</span> madeToIndex..&lt;array.<span class="property">count</span> - <span class="number">1</span> {
            <span class="keyword">let</span> firstLetter = <span class="type">String</span>(array[i])
            <span class="keyword">let</span> secondLetter = <span class="type">String</span>(array[i+<span class="number">1</span>])
            <span class="keyword">if</span> firstLetter.<span class="call">lowercased</span>() == secondLetter.<span class="call">lowercased</span>() &amp;&amp; firstLetter != secondLetter {
                array.<span class="call">remove</span>(at: i)
                array.<span class="call">remove</span>(at: i)
                madeToIndex = i &gt; <span class="number">1</span> ? i - <span class="number">2</span> : <span class="number">0</span>
                <span class="keyword">break</span>
            } <span class="keyword">else if</span> i == array.<span class="property">count</span>-<span class="number">2</span> {
                madeFullPass = <span class="keyword">true</span>
            }
        }
    }
    <span class="keyword">return</span> <span class="type">String</span>(array)
}
</code></pre><p>First, I get an array of the string, so I can loop through it easily and set up helper variables to keep track of whether I have made a full pass yet, and what index I have checked up to so far. Then I make a while loop that will continue until I’ve made a full pass. In side of that, I make a for loop that starts at the index I’ve made it too that I’m sure doesn’t need to be checked again and goes up to the array’s count minus one. Since we’re removing elements, that count is constantly changing, which is why it is necessary to break out of the loop every time we remove elements.</p><p>I get references to the letters I want to check, I make them strings so I can call <code>.lowercased()</code> on them, and then I have a two part test. If they are equal when they are both lowercased, but not equal when they are not, that means they are the same letter, but different cases, which is the criteria we’re looking for. If they meet that criteria, I remove both of them from the array, update the index I’ve made it to so far, and then break out of the current loop. If they don’t meet that criteria, but the index does equal the second to last index in the array, we’ve made a full pass.</p><p>I didn’t originally keep track of the index I have made it to, but it was taking too long, so I added that as a limit to how many times we’d need to run through all of the for loop. It is necessary because of the length of the data and the fact that I am restarting the for loop every time I remove a letter (which happens a lot). Part 1 takes about 0.2 seconds when keeping track of the index, and about 30 seconds when starting the for loop over at 0 every time, meaning it goes about 150 times faster when you make those few simple changes.</p><p>I also made the function return a String because it was easier to troubleshoot while I was writing the code. Then I got the real answer by calling <code>.count</code> on the String given back to me.</p><p>The answer for my input was <code>11720</code> and it takes about 0.2 seconds to calculate when running on the command line as described in <a href="{{"/Advent-of-Code-2018-Setup" | absolute_url}}">my AoC Setup post</a>.</p><h2><a href="https://adventofcode.com/2018/day/5#part2">Problem 2</a></h2><p>I would describe the second problem like this: given the same String as before, return an Int which is the length of the String after all reductions, after removing all of one letter (both cases). The sample data returns 4, which is produced after removing all the <code>c/C's</code></p><h3>Method</h3><p>This is how I solved this problem: - Get a set of all the letters contained in the String (hint: it was all 26 of them.) - Make a dictionary to hold the result after the removal of each letter. - For each letter in the set, filter out that letter and then call <code>collapsePolymer()</code> on it. - Store the result in the dictionary - After all the letters have been checked, find the smallest resulting value and return it.</p><h3>Implementation</h3><p>Here is my function to solve part 2:</p><pre><code><span class="keyword">func</span> testWithoutCertainLetters(<span class="keyword">_</span> string: <span class="type">String</span>) -&gt; <span class="type">Int</span> {
    <span class="keyword">let</span> letters = <span class="type">Set</span>(<span class="type">Array</span>(string.<span class="call">lowercased</span>()))
    <span class="keyword">var</span> resultsDict: [<span class="type">Character</span>: <span class="type">String</span>] = [:]

    <span class="keyword">for</span> letter <span class="keyword">in</span> letters {
        <span class="keyword">let</span> array = <span class="type">Array</span>(string).<span class="call">filter</span>() { <span class="type">String</span>($0).<span class="call">lowercased</span>() != <span class="type">String</span>(letter) }
        <span class="keyword">let</span> result = <span class="call">collapsePolymer</span>(<span class="type">String</span>(array))
        resultsDict[letter] = result
    }

    <span class="keyword">let</span> answer = resultsDict.<span class="call">min</span>(by: { $0.<span class="property">value</span>.<span class="property">count</span> &lt; $1.<span class="property">value</span>.<span class="property">count</span> })
    <span class="keyword">return</span> answer?.<span class="property">value</span>.<span class="property">count</span> ?? -<span class="number">1</span>
}
</code></pre><p>First, I make a Set out of an Array that is made from the input String that has been lowercased. This gives me a set of each letter that is used in the String to check against. Then I make a dictionary of Characters and Strings, to hold the results after removing each letter.</p><p>Then I cycle through the letters, remove them from the String and call <code>collapsePolymer()</code> on it. I store the result in the dictionary with that letter as the key. At the end, I return the smallest result’s count.</p><p>It was only really necessary to keep them in a dictionary because I was curious what the spread looked like with removing each letter and that the winning letter was. Turns out, there wasn’t a lot of variance except with the winning letter. With my input, removing every letter except <code>"w"</code> resulted in a polymer between 11,000 and 11,999 characters long. Removing <code>"w"</code> resulted in the answer of <code>4956</code>. The whole thing takes about 4 seconds to calculate, running on the command line.</p><h2>Reflections</h2><ul><li>This problem forced me to think of creative ways to limit the scope of the function to only what we cared about.</li><li>It also gave me the opportunity to discover this double-loop technique where you keep looping through the outer loop until you make it all the way through the inner loop, and the inner loop keeps restarting every time an element is removed. That technique, paired with keeping track of where you need to restart the inner loop, becomes a fairly efficient way to cycle through the data and compress it. I could imagine a similar technique being used to compress an image or audio file.</li></ul><p>You can find all the code for my attempts so far in <a href="https://github.com/dillon-mce/advent-of-code-2018">my advent of code 2018 repository on GitHub</a>.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://dillon-mce.com/posts/programming-resources</guid><title>Programming Resources</title><description>A list of some good resources I've come across in my time trying to learn programming. It isn't comprehensive, but I've had some people ask about resources to look into, so I thought I'd put my list together in one place.</description><link>https://dillon-mce.com/posts/programming-resources</link><pubDate>Thu, 6 Dec 2018 12:00:00 -0700</pubDate><content:encoded><![CDATA[<p>This is just a list of some good resources I've come across in my time trying to learn programming. It isn't comprehensive, but I've had some people ask about resources to look into, so I thought I'd put my list together in one place. If you have a good resource you think is worth adding to the list, let me know and I'll take a look.</p><h3>General Computer Science &amp; Programming</h3><ul><li><a href="https://www.khanacademy.org/computing/computer-science">Kahn Academy - Computer Science</a></li><li><a href="https://www.khanacademy.org/hourofcode">Kahn Academy - Hour Of Code</a></li><li><a href="https://www.codecademy.com/catalog/subject/all">Codecademy</a></li><li><a href="https://learn.freecodecamp.org/">FreeCodeCamp</a> (especially the Javascript Algorithm section)</li><li><a href="https://www.udemy.com/topic/swift/">Udemy</a> (link goes to the Swift category)</li><li><a href="https://www.apple.com/swift/playgrounds/">Swift Playgrounds</a> (on iPad)</li><li><a href="https://adventofcode.com/">Advent of Code</a></li><li><a href="https://projecteuler.net/">Project Euler</a> - Math-based code challenges</li><li><a href="https://leetcode.com/">Leet Code</a></li><li><a href="https://www.hackerrank.com/">HackerRank</a></li><li><a href="https://www.coderbyte.com/">CoderByte</a></li><li><a href="https://www.amazon.com/Grokking-Algorithms-illustrated-programmers-curious/dp/1617292230">Grokking Algorithms</a> - Easy to read book on algorithms</li></ul><h3>iOS (and MacOS) Specific Resources</h3><ul><li><a href="https://itunes.apple.com/us/book/the-swift-programming-language-swift-4-2/id881256329?mt=11">The Swift Programming Language Guide</a> (<strong>Read this!</strong> Really. Download it on your phone and read one section every day while you're eating breakfast instead of scrolling through Twitter or Instagram or whatever. It'll take 15 minutes and you'll be amazed at how much you pick up.)</li><li><a href="http://swift.org/">Swift.org</a> - Especially the <a href="https://forums.swift.org/">forums</a></li><li><a href="https://swift.org/documentation/api-design-guidelines/">Swift API Design Guidelines</a> - How you should name things</li><li><a href="https://www.raywenderlich.com/">RayWenderlich</a></li><li><a href="https://www.hackingwithswift.com/">Hacking With Swift</a></li><li><a href="https://itunes.apple.com/us/course/developing-ios-11-apps-with-swift/id1309275316">Developing iOS 11 Apps with Swift by Stanford</a></li><li><a href="https://github.com/matteocrippa/awesome-swift">Awesome Swift</a> - list of libraries and resources</li><li><a href="https://nshipster.com/">NSHipster</a></li><li><a href="https://itunes.apple.com/us/book/app-development-with-swift/id1219117996?mt=11">App Development with Swift</a> - Good introduction to developing iOS apps</li></ul>]]></content:encoded></item><item><guid isPermaLink="true">https://dillon-mce.com/posts/aoc2018/day4</guid><title>Advent of Code 2018 - Day 4</title><description>My understanding of Day 4’s first problem is this: given a string like the one below, return an Int that is the minute at which the guard who spent the most total minutes asleep was asleep the most, times that guard’s ID number.</description><link>https://dillon-mce.com/posts/aoc2018/day4</link><pubDate>Wed, 5 Dec 2018 12:00:00 -0700</pubDate><content:encoded><![CDATA[<h2><a href="https://adventofcode.com/2018/day/4">Problem 1</a></h2><p>My understanding of Day 4’s first problem is this: given a string like the one below, return an Int that is the minute at which the guard who spent the most total minutes asleep was asleep the most, times that guard’s ID number. The sample data returns <code>240</code>. Sample data:</p><pre><code>[<span class="number">1518</span>-<span class="number">11</span>-<span class="number">01 00</span>:<span class="number">00</span>] <span class="type">Guard</span> #10 begins shift
[<span class="number">1518</span>-<span class="number">11</span>-<span class="number">01 00</span>:<span class="number">05</span>] falls asleep
[<span class="number">1518</span>-<span class="number">11</span>-<span class="number">01 00</span>:<span class="number">25</span>] wakes up
[<span class="number">1518</span>-<span class="number">11</span>-<span class="number">01 00</span>:<span class="number">30</span>] falls asleep
[<span class="number">1518</span>-<span class="number">11</span>-<span class="number">01 00</span>:<span class="number">55</span>] wakes up
[<span class="number">1518</span>-<span class="number">11</span>-<span class="number">01 23</span>:<span class="number">58</span>] <span class="type">Guard</span> #99 begins shift
[<span class="number">1518</span>-<span class="number">11</span>-<span class="number">02 00</span>:<span class="number">40</span>] falls asleep
[<span class="number">1518</span>-<span class="number">11</span>-<span class="number">02 00</span>:<span class="number">50</span>] wakes up
[<span class="number">1518</span>-<span class="number">11</span>-<span class="number">03 00</span>:<span class="number">05</span>] <span class="type">Guard</span> #10 begins shift
[<span class="number">1518</span>-<span class="number">11</span>-<span class="number">03 00</span>:<span class="number">24</span>] falls asleep
[<span class="number">1518</span>-<span class="number">11</span>-<span class="number">03 00</span>:<span class="number">29</span>] wakes up
[<span class="number">1518</span>-<span class="number">11</span>-<span class="number">04 00</span>:<span class="number">02</span>] <span class="type">Guard</span> #99 begins shift
[<span class="number">1518</span>-<span class="number">11</span>-<span class="number">04 00</span>:<span class="number">36</span>] falls asleep
[<span class="number">1518</span>-<span class="number">11</span>-<span class="number">04 00</span>:<span class="number">46</span>] wakes up
[<span class="number">1518</span>-<span class="number">11</span>-<span class="number">05 00</span>:<span class="number">03</span>] <span class="type">Guard</span> #99 begins shift
[<span class="number">1518</span>-<span class="number">11</span>-<span class="number">05 00</span>:<span class="number">45</span>] falls asleep
[<span class="number">1518</span>-<span class="number">11</span>-<span class="number">05 00</span>:<span class="number">55</span>] wakes up
</code></pre><h3>Method</h3><p>My method for solving this problem looks like this: - Parse the data into a dictionary with the Guard’s IDs as the key, and an array of the dates that they are asleep and awake as the value. - Count up all the minutes each guard is asleep in a dictionary with their ID as the key and an Int of the count of minutes as the value. - Once I find the guard who is asleep for the most minutes, need to figure out which minute they were asleep the most at.	- Make a dictionary of the minute as the key and an Int of the number of times the guard was asleep at that minute as the value.	- Loop through each minute, see if the date range contains that minute and add 1 to the associated key in the dictionary - Return the minute with the largest value times the guard’s ID</p><h3>Implementation</h3><p>My function for parsing the input into a dictionary of guard ID’s and arrays of dates looks like this:</p><pre><code><span class="keyword">func</span> parseInput(<span class="keyword">_</span> string: <span class="type">String</span>) -&gt; [<span class="type">String</span>: [<span class="type">Date</span>]] {
    <span class="keyword">let</span> inputData = string.<span class="call">components</span>(separatedBy: .<span class="dotAccess">newlines</span>).<span class="call">sorted</span>()
    <span class="keyword">let</span> dateFormatter = <span class="type">DateFormatter</span>()
    dateFormatter.<span class="property">dateFormat</span> = <span class="string">"yyyy-MM-dd HH:mm"</span>
    <span class="keyword">var</span> currentGuard = <span class="string">""</span>
    <span class="keyword">var</span> timestampDict: [<span class="type">String</span>: [<span class="type">Date</span>]] = [:]

    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;inputData.<span class="property">count</span> {
        <span class="keyword">let</span> components = inputData[i].<span class="call">components</span>(separatedBy: <span class="type">CharacterSet</span>(charactersIn: <span class="string">"[]"</span>))
        <span class="keyword">if</span> components[<span class="number">2</span>].<span class="call">hasPrefix</span>(<span class="string">" Guard"</span>) {
            <span class="keyword">let</span> num = components[<span class="number">2</span>].<span class="call">components</span>(separatedBy: .<span class="dotAccess">whitespaces</span>)[<span class="number">2</span>]
            currentGuard = num
            <span class="keyword">continue</span>
        }

        <span class="keyword">guard let</span> date = dateFormatter.<span class="call">date</span>(from: components[<span class="number">1</span>]) <span class="keyword">else</span> { <span class="keyword">continue</span> }

        timestampDict[currentGuard, default: []].<span class="call">append</span>(date)
    }

    <span class="keyword">return</span> timestampDict
}
</code></pre><p>I split the input data into an array separated by newlines, and I sort it because the input was not in chronological order. At first I was worried that I would have to write some logic to get it to sort correctly, but it worked out of the box because of the format of the dates in the input string. I make a <code>dateFormatter</code> whose date format matches that of the data, a <code>currentGuard</code> variable to hold the guard I’m currently working with, and a <code>timestampDict</code> variable to hold the parsed data.</p><p>Because each guard has a line that says when they begin their shift, followed by alternating lines saying when they fell asleep and when they woke back up, and because every guard starts their shift awake and always wakes back up for every time they fall asleep, all I need is the dates following the line that says which guard started their shift. I know that the even-indexed elements of the array will all be “falling asleep” dates and all the odd-indexed elements will be “waking up” dates. This becomes relevant later.</p><p>So I split each line on the bracket characters and if the line starts with <code>"Guard"</code>, then I know it is the beginning of a new shift, so I just set <code>currentGuard</code> to that guard’s ID number and continue. For each subsequent line until I hit another that starts with “Guard” I pull out just the date and append it to the array associated with the current Guard’s ID. And at the end I return the dictionary.</p><p>My function for counting the minutes each guard was asleep looks like this:</p><pre><code><span class="keyword">func</span> countMinutesAsleep(<span class="keyword">_</span> guardDict: [<span class="type">String</span>: [<span class="type">Date</span>]]) -&gt; [<span class="type">String</span>: <span class="type">Int</span>] {
    <span class="keyword">var</span> sleepCount: [<span class="type">String</span>: <span class="type">Int</span>] = [:]
    <span class="keyword">for</span> (key, value) <span class="keyword">in</span> guardDict {
        <span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">0</span>..&lt;value.<span class="property">count</span>-<span class="number">1</span> {
            <span class="keyword">if</span> index % <span class="number">2</span> == <span class="number">0</span> {
                <span class="keyword">let</span> interval = <span class="type">DateInterval</span>(start: value[index], end: value[index+<span class="number">1</span>])
                <span class="keyword">let</span> minutes = <span class="type">Int</span>(interval.<span class="property">duration</span>/<span class="number">60</span>)
                sleepCount[key, default: <span class="number">0</span>] += minutes
            }
        }
    }
    <span class="keyword">return</span> sleepCount
}
</code></pre><p>I start by making a dictionary to hold the guard IDs and the number of minutes they’ve been asleep. Then I loop through all the keys and values in the dictionary. Inside of that I loop through each index in 0 up to 1 less that the value’s count. The value here being the array of dates associated with that guard. I only check the even-indexed elements, because those are the falling asleep dates. I make a DateInterval starting at the falling asleep date and ending at the waking up date. Then I get an Int of the interval property from that. The interval property value is in seconds, so I divide that by 60 to get the minute value. Finally I add that to the value for the dictionary at the current key. Once I’m out of both loops, I return the dictionary.</p><p>My function for counting the times a particular guard was a sleep at each minute looks like this:</p><pre><code><span class="keyword">func</span> countTimesAsleepAtMinute(<span class="keyword">_</span> dates: [<span class="type">Date</span>]) -&gt; [<span class="type">Int</span>: <span class="type">Int</span>] {
    <span class="keyword">let</span> minuteFormatter = <span class="type">DateFormatter</span>()
    minuteFormatter.<span class="property">dateFormat</span> = <span class="string">"mm"</span>

    <span class="keyword">var</span> minuteDict: [<span class="type">Int</span>: <span class="type">Int</span>] = [:]
    <span class="keyword">for</span> minute <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="number">60</span> {
        <span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">0</span>..&lt;dates.<span class="property">count</span>-<span class="number">1</span> {
            <span class="keyword">if</span> index % <span class="number">2</span> == <span class="number">0</span> {
                <span class="keyword">guard let</span> fallAsleep = <span class="type">Int</span>(minuteFormatter.<span class="call">string</span>(from: dates[index])),
                    <span class="keyword">let</span> wakeUp = <span class="type">Int</span>(minuteFormatter.<span class="call">string</span>(from: dates[index+<span class="number">1</span>])) <span class="keyword">else</span> { <span class="keyword">continue</span> }
                <span class="keyword">if</span> minute &gt;= fallAsleep &amp;&amp; minute &lt; wakeUp {
                    minuteDict[minute, default: <span class="number">0</span>] += <span class="number">1</span>
                }
            }
        }
    }
    <span class="keyword">return</span> minuteDict
} <span class="type">I</span>
</code></pre><p>I make a dateFormatter that will pull out just the minute value from a date (because that is all that is relevant in the given data), and a dictionary to hold the minutes and counts. Then I loop through every value from 0 up to 60 (all of the minute values), and inside of that, loop through all of the dates in the array. Again, I only check the even-indexed items because those are the “falling asleep” dates. I use my minute formatted to get the <code>fallAsleep</code> minute and the <code>wakeUp</code> minute and if the current minute is between those two values, I add 1 to the dictionary value at the current minute’s key. This is not the most efficient way to do this, but it works and is efficient enough for the given data.</p><p>Finally, my main function to solve the problem looks like this:</p><pre><code><span class="keyword">func</span> findSleepyGuard1(<span class="keyword">_</span> string: <span class="type">String</span>) -&gt; <span class="type">Int</span> {
    <span class="keyword">let</span> timestampDict = <span class="call">parseInput</span>(string)
    <span class="keyword">let</span> sleepCount = <span class="call">countMinutesAsleep</span>(timestampDict)

    <span class="keyword">guard let</span> biggest = sleepCount.<span class="call">max</span>(by: { $0.<span class="property">value</span> &lt; $1.<span class="property">value</span> }) <span class="keyword">else</span> { <span class="keyword">return</span> -<span class="number">1</span> }

    <span class="keyword">let</span> sleepyGuardArray = timestampDict[biggest.<span class="property">key</span>] ?? []
    <span class="keyword">let</span> minuteDict = <span class="call">countTimesAsleepAtMinute</span>(sleepyGuardArray)

    <span class="keyword">guard let</span> frequentlyAsleep = minuteDict.<span class="call">max</span>(by: { $0.<span class="property">value</span> &lt; $1.<span class="property">value</span> }) <span class="keyword">else</span> { <span class="keyword">return</span> -<span class="number">1</span> }

    <span class="keyword">let</span> minute = frequentlyAsleep.<span class="property">key</span>
    <span class="keyword">let</span> guardId = <span class="type">Int</span>(biggest.<span class="property">key</span>.<span class="call">components</span>(separatedBy: <span class="type">CharacterSet</span>(charactersIn: <span class="string">"#"</span>)).<span class="call">joined</span>()) ?? <span class="number">0</span>

    <span class="keyword">return</span> minute * guardId
}
</code></pre><p>I get a dictionary of the times each guard is asleep from the <code>pasreInput()</code> function and a dictionary of how many minutes each guard spent asleep from the <code>countMinutesAsleep()</code> function. I pull the guard who was asleep the most out of that dictionary, and then I call	<code>countTimesAsleepAtMinute()</code> with their associated dates. I pull the minute they were frequently asleep out of that dictionary and then multiply it by the guard’s ID number.</p><p>The answer for my input was <code>85296</code> and it takes about 40 milliseconds to find it using the Swift script method described in <a href="{{"/Advent-of-Code-2018-Setup" | absolute_url}}">my AoC Setup post</a>.</p><h2><a href="https://adventofcode.com/2018/day/4#part2">Problem 2</a></h2><p>I would describe the second problem like this: given the same input String, return an Int which is the ID number of the guard who is asleep at the same minute the most, times the minute at which they are asleep the most. The sample data returns <code>4455</code>.</p><h3>Method</h3><p>This is how I solved this problem: - Use the same <code>parseInput()</code> function to get a dictionary of guard IDs and arrays of dates. - Write a function that does the same thing as <code>countTimesAsleepAtMinute()</code> in the previous part, but does it for every guard and returns a dictionary of guard IDs and minute dictionaries. - Once I have that dictionary, find the guard who was asleep the most frequently at any given minute. - Return the minute times the guard’s ID</p><h3>Implementation</h3><p>My new <code>countTimesAsleepAtMinute()</code> function looks like this:</p><pre><code><span class="keyword">func</span> countTimesAsleepAtMinute(<span class="keyword">_</span> dates: [<span class="type">String</span>: [<span class="type">Date</span>]]) -&gt; [<span class="type">String</span>: [<span class="type">Int</span>: <span class="type">Int</span>]] {
    <span class="keyword">let</span> minuteFormatter = <span class="type">DateFormatter</span>()
    minuteFormatter.<span class="property">dateFormat</span> = <span class="string">"mm"</span>

    <span class="keyword">var</span> minuteDict: [<span class="type">String</span>: [<span class="type">Int</span>: <span class="type">Int</span>]] = [:]
    <span class="keyword">for</span> (guardID, times) <span class="keyword">in</span> dates {
      <span class="keyword">for</span> (guardID, times) <span class="keyword">in</span> dates {
      minuteDict[guardID] = <span class="call">countTimesAsleepAtMinute</span>(times)
      ß}
    }
    <span class="keyword">return</span> minuteDict
}
</code></pre><p>I’ve added yet another loop outside of the others calls my old <code>countTimesAsleepAtMinute()</code> function, and it saves the resulting array into the result dictionary, using the guard’s ID as the key. This is where the efficiency of those inner loops starts to make a difference, but for the given data, the extra time it takes is still negligible.</p><p>My main function looks like this:</p><pre><code><span class="keyword">func</span> findSleepyGuard2(<span class="keyword">_</span> string: <span class="type">String</span>) -&gt; <span class="type">Int</span> {
    <span class="keyword">let</span> timestampDict = <span class="call">parseInput</span>(string)
    <span class="keyword">let</span> minuteDict = <span class="call">countTimesAsleepAtMinute</span>(timestampDict)

    <span class="keyword">var</span> mostMinutes: (key: <span class="type">Int</span>, value: <span class="type">Int</span>) = (<span class="number">0</span>, <span class="number">0</span>)
    <span class="keyword">var</span> consistentlySleepyGuard = <span class="string">""</span>
    <span class="keyword">for</span> (guardId, dict) <span class="keyword">in</span> minuteDict {
        <span class="keyword">guard let</span> max = dict.<span class="call">max</span>(by: { $0.<span class="property">value</span> &lt; $1.<span class="property">value</span> }) <span class="keyword">else</span> { <span class="keyword">continue</span> }
        <span class="comment">//print("Guard \(guardId) was asleep at minute \(max.key) \(max.value) times")</span>
        <span class="keyword">if</span> max.<span class="property">value</span> &gt; mostMinutes.<span class="property">value</span> {
            mostMinutes = max
            consistentlySleepyGuard = guardId
        }
    }

    <span class="keyword">let</span> minute = mostMinutes.<span class="property">key</span>
    <span class="keyword">let</span> guardId = <span class="type">Int</span>(consistentlySleepyGuard.<span class="call">components</span>(separatedBy: <span class="type">CharacterSet</span>(charactersIn: <span class="string">"#"</span>)).<span class="call">joined</span>()) ?? <span class="number">0</span>

    <span class="keyword">return</span> minute * guardId
}
</code></pre><p>I get a dictionary of guard IDs and arrays of dates from the <code>parseInput()</code> function and I get a dictionary of guard IDs and dictionaries of minutes and minute counts from the <code>countTimesAsleepAtMinute()</code> function. Then I make variables to hold a tuple of the mostMinutes info and a string of the most consistently sleep guard. Then I loop through all the keys and values in the dictionary, pull the max value out of the value dictionary and if it’s value is bigger than the current <code>mostMinutes</code>, set <code>mostMinutes</code> to it and set the <code>consistentlySleepyGuard</code> to the current key. At the end, I return the guard ID number times the minute.</p><p>The answer for my input was <code>58559</code> and it takes about 0.2 seconds to find it using the script method.</p><h2>Reflections</h2><ul><li>This problem gave me the opportunity to practice with dictionaries and arrays, and nesting them within each other.</li><li>It also forced me to think about the computation complexity nested loops.</li></ul><p>You can find all the code for my attempts so far in <a href="https://github.com/dillon-mce/advent-of-code-2018">my advent of code 2018 repository on GitHub</a>.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://dillon-mce.com/posts/aoc2018/day3</guid><title>Advent of Code 2018 - Day 3</title><description>My understanding of day 3’s first problem is this: given a string that is a list of fabric claims like "#1 @ 1,3: 4x4 #2 @ 3,1: 4x4 #3 @ 5,5: 2x2" on a large grid of fabric (with the coordinates starting at the top left), return an Int which is the number square inches claimed more than once.</description><link>https://dillon-mce.com/posts/aoc2018/day3</link><pubDate>Tue, 4 Dec 2018 12:00:00 -0700</pubDate><content:encoded><![CDATA[<h2><a href="https://adventofcode.com/2018/day/3">Problem 1</a></h2><p>My understanding of day 3’s first problem is this: given a string that is a list of fabric claims like <code>"#1 @ 1,3: 4x4\n#2 @ 3,1: 4x4\n#3 @ 5,5: 2x2"</code> on a large grid of fabric (with the coordinates starting at the top left), return an Int which is the number square inches claimed more than once. The sample data returns <code>4</code>.</p><h3>Method</h3><p>To solve this problem I needed: - To define a Point struct to deal with coordinates - Define a Claim struct that has an id, a size (x, y, h, w)	- It also needs a computed property that is a set of the points it contains	- A method that returns the points that intersect with another claim	- A method to check if there is any overlap between claims. At first I thought I would only need the first two, but I found that it was too calculation time intensive, so I added a faster function that just does a little math to see if they overlap, and only getting all their points and finding the intersection if we know they overlap. - A helper method to parse the input into an array of Claims - The main function which will have a set of points, loop through all the claims, check them for overlapping area with all the other claims, and if it finds any, get their intersecting points and add them to the set.</p><h3>Implementation</h3><p>My Point struct is pretty straightforward, it looks like this:</p><pre><code><span class="keyword">struct</span> Point: <span class="type">Hashable</span>, <span class="type">CustomStringConvertible</span> {
    <span class="keyword">let</span> x: <span class="type">Int</span>
    <span class="keyword">let</span> y: <span class="type">Int</span>

    <span class="keyword">var</span> description: <span class="type">String</span> {
        <span class="keyword">return</span> <span class="string">"Point(x:</span> \(x)<span class="string">, y:</span> \(y)<span class="string">)"</span>
    }

}
</code></pre><p>It is hashable, so that I can make a set of Points, and I added a custom description, to make things a little easier to read when I printed stuff out.</p><p>The Claim struct looks like this:</p><pre><code><span class="keyword">struct</span> Claim: <span class="type">Hashable</span> {
    <span class="keyword">let</span> id: <span class="type">String</span>
    <span class="keyword">let</span> x: <span class="type">Int</span>
    <span class="keyword">let</span> y: <span class="type">Int</span>
    <span class="keyword">let</span> height: <span class="type">Int</span>
    <span class="keyword">let</span> width: <span class="type">Int</span>

    <span class="keyword">var</span> internalPoints: <span class="type">Set</span>&lt;<span class="type">Point</span>&gt; {
        <span class="keyword">var</span> set: <span class="type">Set</span>&lt;<span class="type">Point</span>&gt; = <span class="type">Set</span>()
        <span class="keyword">for</span> x <span class="keyword">in</span> x..&lt;(x + width) {
            <span class="keyword">for</span> y <span class="keyword">in</span> y..&lt;(y + height) {
                <span class="keyword">let</span> point = <span class="type">Point</span>(x: x, y: y)
                set.<span class="call">insert</span>(point)
            }
        }
        <span class="keyword">return set</span>
    }
}
</code></pre><p>I probably could have defined it to use a point instead of an x and y, and maybe also defined the height and width off of a second point, but as I was thinking through this problem, I started with the Claim struct and by the time I had a Point, I didn’t want to go back and rewrite the code I had. It may make some of the math easier though. Probably worth looking into at some point. Other than that, the only interesting thing here is the internal point property, which calculates a set of all the internal points each time it is called. This cuts down on memory usage, but increases calculation time, which is why I try to only call it it when I have to.</p><p>The function that returns a set of intersecting points looks like this:</p><pre><code><span class="keyword">func</span> getIntersectionPoints(with claim: <span class="type">Claim</span>) -&gt; <span class="type">Set</span>&lt;<span class="type">Point</span>&gt; {
    <span class="keyword">return self</span>.<span class="property">internalPoints</span>.<span class="call">intersection</span>(claim.<span class="property">internalPoints</span>)
}
</code></pre><p>It just finds and returns the intersection of the claim it is called on’s internal points and the claim it is called with’s internal points.</p><p>The function which calculates the overlapping area looks like this:</p><pre><code><span class="keyword">func</span> overlappingArea(with claim: <span class="type">Claim</span>) -&gt; <span class="type">Int</span> {
    <span class="keyword">let</span> overlapX = <span class="call">min</span>((<span class="keyword">self</span>.<span class="property">x</span> + <span class="keyword">self</span>.<span class="property">width</span>), (claim.<span class="property">x</span> + claim.<span class="property">width</span>)) - <span class="call">max</span>(<span class="keyword">self</span>.<span class="property">x</span>, claim.<span class="property">x</span>)
    <span class="keyword">let</span> overlapY = <span class="call">min</span>((<span class="keyword">self</span>.<span class="property">y</span> + <span class="keyword">self</span>.<span class="property">height</span>), (claim.<span class="property">y</span> + claim.<span class="property">height</span>)) - <span class="call">max</span>(<span class="keyword">self</span>.<span class="property">y</span>, claim.<span class="property">y</span>)

    <span class="keyword">guard</span> overlapX &gt; <span class="number">0</span>, overlapY &gt; <span class="number">0</span> <span class="keyword">else</span> { <span class="keyword">return</span> <span class="number">0</span> }

    <span class="keyword">return</span> overlapX * overlapY

}
</code></pre><p>I got the math from this <a href="https://www.geeksforgeeks.org/total-area-two-overlapping-rectangles/">Geeks for Geeks article</a> and modified it a little to fit the need here (the math in the article assumes there is some overlap). Basically you get the whichever right side of the rectangle is smaller and subtract whichever left side is bigger and if the result is positive, they over lap on the x-axis. You do the same for the y-axis and if they are both positive, it means there is some overlap. I return an Int in case at some point I need to know how much they overlap, but I could just have easily returned a Bool because all I really need to know is if they overlap or not.</p><p>My function to parse the claim looks like this:</p><pre><code><span class="keyword">func</span> parseInput(<span class="keyword">_</span> string: <span class="type">String</span>) -&gt; [<span class="type">Claim</span>] {
    <span class="keyword">let</span> array = string.<span class="call">components</span>(separatedBy: .<span class="dotAccess">newlines</span>)
    <span class="keyword">var</span> results: [<span class="type">Claim</span>] = []

    <span class="keyword">for</span> (index, item) <span class="keyword">in</span> array.<span class="call">enumerated</span>() {
        <span class="keyword">let</span> secondArray = item.<span class="call">components</span>(separatedBy: .<span class="dotAccess">whitespaces</span>)
        <span class="keyword">let</span> id = secondArray[<span class="number">0</span>]
        <span class="keyword">let</span> originArray = secondArray[<span class="number">2</span>].<span class="call">components</span>(separatedBy: .<span class="dotAccess">punctuationCharacters</span>)
        <span class="keyword">let</span> boundsArray = secondArray[<span class="number">3</span>].<span class="call">components</span>(separatedBy: .<span class="dotAccess">lowercaseLetters</span>)
        <span class="keyword">guard let</span> x = <span class="type">Int</span>(originArray[<span class="number">0</span>]),
            <span class="keyword">let</span> y = <span class="type">Int</span>(originArray[<span class="number">1</span>]),
            <span class="keyword">let</span> width = <span class="type">Int</span>(boundsArray[<span class="number">0</span>]),
            <span class="keyword">let</span> height = <span class="type">Int</span>(boundsArray[<span class="number">1</span>]) <span class="keyword">else</span> {
                <span class="call">print</span>(<span class="string">"Couldn't convert something correctly. Check loop</span> \(index + <span class="number">1</span>)<span class="string">"</span>)
                <span class="call">print</span>(<span class="string">"Array:</span> \(secondArray)<span class="string">"</span>)
                <span class="keyword">continue</span>
        }
        <span class="keyword">let</span> claim = <span class="type">Claim</span>(id: id, x: x, y: y, height: height, width: width)
        results.<span class="call">append</span>(claim)
    }

    <span class="keyword">return</span> results
}
</code></pre><p>It is a little bit of a mess. I start by splitting the input string into an array by newlines and giving myself an array to hold the claims that are made. Then I loop through the array to make a Claim out of each line. I used <code>.enumerated()</code> so I could grab the index for my print out if something failed.</p><p>To make a Claim, I split each line by whitespaces. The id is the first element of that array. The origin point is the third element in the array, which I split on punctuation. The height and width are the fourth element, which I split on lowercase letters, because it is an <code>"x"</code> in the input. I then pull out the individual elements, turn them into Ints and store them in variables. It that is successful, I make a claim from the pieces and append it to the array.</p><p>Finally, my main function looks like this:</p><pre><code><span class="keyword">func</span> addOverlappingArea(<span class="keyword">_</span> string: <span class="type">String</span>) -&gt; <span class="type">Int</span> {
    <span class="keyword">let</span> claims = <span class="call">parseInput</span>(string)
    <span class="keyword">var</span> points: <span class="type">Set</span>&lt;<span class="type">Point</span>&gt; = <span class="type">Set</span>()
    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;claims.<span class="property">count</span>-<span class="number">1</span> {
        <span class="keyword">for</span> j <span class="keyword">in</span> i+<span class="number">1</span>..&lt;claims.<span class="property">count</span> {
            <span class="keyword">let</span> claim1 = claims[i]
            <span class="keyword">let</span> claim2 = claims[j]
            <span class="keyword">if</span> claim1.<span class="call">overlappingArea</span>(with: claim2) &gt; <span class="number">0</span> {
                points.<span class="call">formUnion</span>(claim1.<span class="call">getIntersectionPoints</span>(with: claim2))
            }
        }
    }
    <span class="keyword">return</span> points.<span class="property">count</span>
}
</code></pre><p>I get an array of claims from my <code>parseInput()</code> function and make an empty array of points to hold the overlapping points. Then I loop through the claims and check each one against all the others to see if they overlap, and if they do I get a set of of the intersecting points and add that to my points set.</p><p>The answer for my input was 111326 and it takes about 0.6 seconds to find the answer using the swift script method described in <a href="{{"/Advent-of-Code-2018-Setup" | absolute_url}}">my AoC setup post</a>.</p><h2><a href="https://adventofcode.com/2018/day/3#part2">Problem 2</a></h2><p>Part two was much simpler, now that I had all the infrastructure built out. The problem is basically: given a string of claims, return the ID of the single claim that doesn’t overlap with any others. The sample data returns <code>#3</code>.</p><h3>Method</h3><ul><li>Use the same <code>parseInput()</code> method to get an array of claims.</li><li>Make a set of Claims to hold the claims with no overlaps.</li><li>Loop through all the claims, checking them against all the others and if they have any overlap, remove both from the set.</li><li>At the end, if there is an element left, return it.</li></ul><h3>Implementation</h3><p>The only new code for this part was the main function:</p><pre><code><span class="keyword">func</span> findNoOverlaps(<span class="keyword">_</span> string: <span class="type">String</span>) -&gt; <span class="type">Claim</span>? {
    <span class="keyword">let</span> claims = <span class="call">parseInput</span>(string)
    <span class="keyword">var</span> noOverlaps: <span class="type">Set</span>&lt;<span class="type">Claim</span>&gt; = <span class="type">Set</span>(claims)
    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;claims.<span class="property">count</span> {
        <span class="keyword">for</span> j <span class="keyword">in</span> i+<span class="number">1</span>..&lt;claims.<span class="property">count</span> {
            <span class="keyword">let</span> claim1 = claims[i]
            <span class="keyword">let</span> claim2 = claims[j]
            <span class="keyword">if</span> claim1.<span class="call">overlappingArea</span>(with: claim2) &gt; <span class="number">0</span> {
                noOverlaps.<span class="call">remove</span>(claim1)
                noOverlaps.<span class="call">remove</span>(claim2)
            }
        }
    }
    <span class="keyword">return</span> noOverlaps.<span class="property">count</span> == <span class="number">1</span> ? noOverlaps.<span class="call">removeFirst</span>() : <span class="keyword">nil</span>
}
</code></pre><p>I get my claims from the <code>parseInput()</code> function, and make a set equal from that array of claims. Then I loop through each claim, checking it against all the other claims for an overlap. If there is any, I remove both from the set. This will loop through all of the claims, even if they have already been removed from the set, but I didn’t want to take the time to write it in a more efficient way because it already takes a negligible amount of time for the given input.</p><p>The answer for my input was claim #1019 and it takes about 0.2 seconds to find it running the script on the command line.</p><h2>Reflections</h2><ul><li>This problem really stretched my memory of high school geometry class, and forced me to think about how to deal with a coordinate system in code.</li><li>It also gave me the opportunity to explore the capabilities of Sets a little more, as well as making custom structs that are Hashable.</li></ul><p>You can find all the code for my attempts so far in <a href="https://github.com/dillon-mce/advent-of-code-2018">my advent of code 2018 repository on GitHub</a>.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://dillon-mce.com/posts/aoc2018/day2</guid><title>Advent of Code 2018 - Day 2</title><description>My understanding of the second day’s first problem was this: given a list of IDs like "abcdef bababc abbcde abcccd aabcdd abcdee ababab", return a checksum which is the number of IDs that contain exactly two of the same character *times* the number of IDs that contain exactly three of the same character.</description><link>https://dillon-mce.com/posts/aoc2018/day2</link><pubDate>Mon, 3 Dec 2018 12:00:00 -0700</pubDate><content:encoded><![CDATA[<h2><a href="https://adventofcode.com/2018/day/2">Problem 1</a></h2><p>My understanding of the second day’s first problem was this: given a list of IDs like <code>"abcdef bababc abbcde abcccd aabcdd abcdee ababab"</code>, return a checksum which is the number of IDs that contain exactly two of the same character <em>times</em> the number of IDs that contain exactly three of the same character. IDs can count towards both numbers. The sample returns <code>12</code>.</p><h3>Method</h3><ul><li>Break up the input into an array of the individual IDs</li><li>Write a function that takes a string and a count (int) and returns a bool that is whether that string contains exactly “count” of any letter</li><li>Filter the array using that function for count 2</li><li>Filter the array using that function for count 3</li><li>Multiply the counts of the filtered arrays together</li></ul><h3>Implementation</h3><p>Again, I start my function by saying <code>let array = string.components(separatedBy: .whitespacesAndNewlines)</code>. That gets me an array of strings which are the IDs.</p><p>Then I write my helper function.</p><pre><code><span class="keyword">func</span> containsMultiples(<span class="keyword">_</span> string: <span class="type">String</span>, count: <span class="type">Int</span>) -&gt; <span class="type">Bool</span> {
    <span class="keyword">let</span> letters = <span class="type">Set</span>(string)
    <span class="keyword">for</span> letter <span class="keyword">in</span> letters {
        <span class="keyword">let</span> filtered = string.<span class="call">filter</span>() { $0 == letter }
        <span class="keyword">if</span> filtered.<span class="property">count</span> == count { <span class="keyword">return true</span> }
    }
    <span class="keyword">return false</span>
}
</code></pre><p>This loops through each letter in the string, creates a filtered array of letters that are the same as the current letter, and checks if the filtered array’s count is the same as the count parameter given when the function is called. It returns true for the first one it finds, and if it doesn’t find any it returns false.</p><p>After that, the rest of the <code>produceCheckSum</code> function is pretty straightforward:</p><pre><code><span class="keyword">let</span> contains2 = array.<span class="call">filter</span>() { <span class="call">containsMultiples</span>($0, count: <span class="number">2</span>) }.count
<span class="keyword">let</span> contains3 = array.<span class="call">filter</span>() { <span class="call">containsMultiples</span>($0, count: <span class="number">3</span>) }.count

<span class="keyword">let</span> result = contains2 * contains3
</code></pre><p>I get one array which is all the IDs that have at least one set of two identical characters, and then I get an array which is all the IDs that have at least one set of three identical characters, and then I multiply their counts together.</p><p>The answer for my input was 5000, and with the command line method described in <a href="{{"/Advent-of-Code-2018-Setup" | absolute_url}}">my AoC Setup post</a>, it takes about 30 milliseconds to find it.</p><h2><a href="https://adventofcode.com/2018/day/2#part2">Problem 2</a></h2><p>I would describe the problem for part 2 like this: given a list of IDs like <code>"abcde fghij klmno pqrst fguij axcye wvxyz"</code>, return a string that is the common letters between the two IDs that only differ by one letter. The sample returns <code>"fgij"</code>.</p><h3>Method</h3><ul><li>Break up the array into individual IDs</li><li>Write a helper function that takes two strings, checks for mismatches between them, and returns a bool that is whether the mismatches is less than 2.</li><li>Loop through all the IDs and get an array that is filtered by that helper function. If that filtered array is more than 1 element long, break out of the loop.</li><li>Loop through the two ID’s characters and, if they are the same, add them to a result string.</li></ul><h3>Implementation</h3><p>I break up the array in the same way described above. Then, my helper function looks like this:</p><pre><code><span class="keyword">func</span> filterStrings(<span class="keyword">_</span> string1: <span class="type">String</span>, <span class="keyword">_</span> string2: <span class="type">String</span>) -&gt; <span class="type">Bool</span> {
    <span class="keyword">var</span> mismatches = <span class="number">0</span>
    <span class="keyword">let</span> array1 = <span class="type">Array</span>(string1)
    <span class="keyword">let</span> array2 = <span class="type">Array</span>(string2)
    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;string1.<span class="property">count</span> {
        <span class="keyword">if</span> array1[i] != array2[i] { mismatches += <span class="number">1</span> }
    }
    <span class="keyword">return</span> mismatches &lt; <span class="number">2</span>
}
</code></pre><p>I start with the mismatches at 0, loop through the indexes in the first array, and check them against the character at the same index in the other array. Then, return a bool that is if the mismatches is less than 2. This method assumes both of the ID strings are the same length, which is how the input is formatted. If the IDs weren’t all the same length, you’d probably want to check for that.</p><p>The rest of my <code>findCommonLetters()</code> function looks like this:</p><pre><code><span class="keyword">var</span> resultString = <span class="string">""</span>
<span class="keyword">var</span> filtered: [<span class="type">String</span>] = []

<span class="keyword">for</span> id <span class="keyword">in</span> array {
    filtered = array.<span class="call">filter</span>() { <span class="call">filterString</span>(id, $0) }
    <span class="keyword">if</span> filtered.<span class="property">count</span> &gt; <span class="number">1</span> { <span class="keyword">break</span> }
}

<span class="keyword">let</span> array1 = <span class="type">Array</span>(filtered[<span class="number">0</span>])
<span class="keyword">let</span> array2 = <span class="type">Array</span>(filtered[<span class="number">1</span>])
<span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;array1.<span class="property">count</span> {
    <span class="keyword">if</span> array1[i] == array2[i] { resultString += <span class="type">String</span>(array1[i]) }
}
</code></pre><p>First, I define a string and an array to hold my results. Then I loop through the IDs, filter them using my helper function, and break out of the loop if the count of the filtered array is greater than 1. Then I grab references to the two ID arrays and loop through them, check if the letters are the same and append the letter to my result string if they are.</p><p>The answer for my input was <code>"ymdrchgpvwfloluktajxijsqb"</code> and it takes about 0.15 seconds to find it running as a Swift script.</p><h2>Reflections</h2><ul><li>This problem gave me the opportunity to explore <code>.filter()</code> a little more, as well as defining the logic for it in an external function.</li><li>I did have to resort to accessing elements of the arrays by index in a few places, which is not particularly “Swifty”, but I couldn’t come up with a reasonable alternative in a short amount of time.</li></ul><p>You can find all the code for my attempts so far in <a href="https://github.com/dillon-mce/advent-of-code-2018">my advent of code 2018 repository on GitHub</a>.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://dillon-mce.com/posts/aoc2018/day1</guid><title>Advent of Code 2018 - Day 1</title><description>My understanding of day 1’s first problem was this: given a string like "+1, -2, +3, +1" , return the Int it reduces to if you add and subtract all the numbers, starting at 0.</description><link>https://dillon-mce.com/posts/aoc2018/day1</link><pubDate>Sun, 2 Dec 2018 12:00:00 -0700</pubDate><content:encoded><![CDATA[<h2><a href="https://adventofcode.com/2018/day/1">Problem 1</a></h2><p>My understanding of day 1’s first problem was this: given a string like <code>"+1, -2, +3, +1"</code> , return the Int it reduces to if you add and subtract all the numbers, starting at 0. The actual input was much longer and the elements were separated by newlines instead of spaces, but I accounted for that in my function. The sample data returns <code>3</code></p><h3>Method</h3><p>Here’s how I broke down the problem: - Break up the string into an array - Define a variable to hold the result - Loop through that array and if the element starts with “+”, add it to result and if it starts with “-“ subtract it from result. (I realized later that it was probably a little cleaner to filter them into two separate arrays based on the first character, and then run reduce on each of those arrays, so I switched to that method.)</p><h3>Implementation</h3><p>Swift has a great method for splitting strings into an array, separated by built in character sets (or one’s you define yourself) called <code>.components(separatedBy: )</code> and one of the built in sets is called <code>.whitespacesAndNewlines</code> so breaking up the string is fairly simple.</p><p>The result just needed to start at 0, so I set that. I also defined a custom CharacterSet for myself so I could use that to get the number without the sign in front of it. <code>let characterSet = CharacterSet(charactersIn: "+-"</code></p><p>Here is my original pass at the calculations, using a for loop:</p><pre><code><span class="keyword">for</span> element <span class="keyword">in</span> array {
        <span class="keyword">guard let</span> number = <span class="type">Int</span>(element.<span class="call">components</span>(separatedBy: characterSet).<span class="call">joined</span>()) <span class="keyword">else</span> { <span class="keyword">continue</span> }
        <span class="keyword">if</span> element.<span class="property">first</span> == <span class="string">"+"</span> {
            result += number
        } <span class="keyword">else if</span> element.<span class="property">first</span> == <span class="string">"-"</span> {
            result -= number
        }
    }
</code></pre><p>I make sure I can get the number, and then if the element starts with <code>"+"</code> I add it to the result, and if it starts with <code>"-"</code> I subtract it.</p><p>Here is the method with filter and reduce:</p><pre><code><span class="keyword">let</span> additions = array.<span class="call">filter</span>({ $0.<span class="call">hasPrefix</span>(<span class="string">"+"</span>) }).<span class="call">compactMap</span>() {<span class="type">Int</span>($0.<span class="call">components</span>(separatedBy: characterSet).<span class="call">joined</span>())}
    <span class="keyword">let</span> subtractions = array.<span class="call">filter</span>({ $0.<span class="call">hasPrefix</span>(<span class="string">"-"</span>) }).<span class="call">compactMap</span>() {<span class="type">Int</span>($0.<span class="call">components</span>(separatedBy: characterSet).<span class="call">joined</span>())}

    result = additions.<span class="call">reduce</span>(result, +)
    result = subtractions.<span class="call">reduce</span>(result, -)
</code></pre><p>I filter by the plus or minus sign and then compact map the results to integers of the string without the plus and minus signs. Then I can just set the result to be the reductions of the two arrays.</p><p>At the very end I print and return the result. Problem solved. The answer for my input was 592.</p><h2><a href="https://adventofcode.com/2018/day/1#part2">Problem 2</a></h2><p>I would describe the second problem like this: given a string like <code>"+1, -2, +3, +1"</code>, return the first integer that is achieved twice in the sequence. If none is found the first time through, loop through it until you find one. The sample data returns <code>2</code></p><h3>Method</h3><ul><li>Break up the string into an array</li><li>Make a set to hold the frequencies hit, a variable to hold the current frequency and a variable to hold the result</li><li>Make an outer while loop that will continue until a result is achieved</li><li>Inside of the while loop, use the loop from part 1 to loop through and add/subtract each element to the current frequency.</li><li>Check if the frequency is contained in the set of frequencies hit and if it is, set the result to the current frequency and break out of the loop.</li><li>If it isn’t, insert it into the set.</li></ul><h3>Implementation</h3><p>My function definition is the same, it takes in a string and returns an Int, but I renamed it to <code>calculateFirstReusedFreq()</code>.</p><p>I used the same method as in part 1 to split the array and many of the variables I used were the same. The ones that are different are: - I set the result to be an optional Int <code>Int?</code> so that I could set it to nil for the while loop. - I added a frequency variable to hold the current frequency (same as the result variable in part 1) - I added a <code>frequenciesHit: Set&lt;Int&gt;</code> variable to hold all the frequencies that had been hit so far. I chose a Set because the complexity of a look-up in a Set in Swift is O(1), so it wouldn’t take longer to check the current frequency against it as it grew. - I also added a count variable that just kept track of how many times I needed to loop through the while loop to arrive at an answer (mostly because I was curious).</p><p>My while loop looks like this:</p><pre><code><span class="keyword">while</span> result == <span class="keyword">nil</span> {
        count += <span class="number">1</span>
        <span class="keyword">for</span> element <span class="keyword">in</span> array {
            <span class="keyword">guard let</span> number = <span class="type">Int</span>(element.<span class="call">components</span>(separatedBy: characterSet).<span class="call">joined</span>()) <span class="keyword">else</span> { <span class="keyword">continue</span> }
            <span class="keyword">if</span> element.<span class="property">first</span> == <span class="string">"+"</span> {
                frequency += number
            } <span class="keyword">else if</span> element.<span class="property">first</span> == <span class="string">"-"</span> {
                frequency -= number
            }
            <span class="keyword">if</span> frequenciesHit.<span class="call">contains</span>(frequency) {
                result = frequency
                <span class="keyword">break</span>
            }
            frequenciesHit.<span class="call">insert</span>(frequency)
        }
    }
</code></pre><p>The logic in the for loop is largely the same as part 1, except that I had to switch back to the for loop method so I could get access to each frequency as we went. Then I just check to see if the frequency has been hit before, set it as the result and break if it has, and add it to the set of frequencies hit if it hasn’t. And I just keep looping that loop until I get a result.</p><p>Once I get out of the while loop I print and return the result. Problem solved. The answer for my input was 241 (found on the 137th time through the while loop) and it took a little over 8 seconds to arrive at that answer running in a playground on my 2018 MacBook.</p><p>You can find all the code for my attempts so far in <a href="https://github.com/dillon-mce/advent-of-code-2018">my advent of code 2018 repository on GitHub</a>.</p><p><strong>Update:</strong> After I switched over to the command line script method described in <a href="{{"/Advent-of-Code-2018-Setup" | absolute_url}}">my AoC 2018 Setup post</a>, part 1 takes 5 milliseconds, and part 2 takes 0.5 seconds on the same MacBook.</p>]]></content:encoded></item></channel></rss>