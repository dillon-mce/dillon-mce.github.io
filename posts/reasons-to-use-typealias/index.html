<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>5 Reasons to Use Typealias | Develop with Dillon</title><meta name=keywords content="Swift"><meta name=description content="Swift has many features that allow us as the users of the language to customize how we write code, while still giving us all the protections of a statically typed language. Today we&rsquo;re going to talk about one of those features which seems small, but it packs a lot of punch.
The typealias keyword lets you define a &ldquo;type alias&rdquo;, a custom name for a class, struct or any other existing type in Swift."><meta name=author content><link rel=canonical href=https://dillon-mce.com/posts/reasons-to-use-typealias/><link crossorigin=anonymous href=/assets/css/stylesheet.min.ae9017796fc0b71882930de374a7047229b17dd0004f5e7d194bd3dc1413bee5.css integrity="sha256-rpAXeW/AtxiCkw3jdKcEcimxfdAAT159GUvT3BQTvuU=" rel="preload stylesheet" as=style><link rel=icon href=https://dillon-mce.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://dillon-mce.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://dillon-mce.com/favicon-32x32.png><link rel=apple-touch-icon href=https://dillon-mce.com/apple-touch-icon.png><link rel=mask-icon href=https://dillon-mce.com/favicon-32x32.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-YZRJY88933"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-YZRJY88933")</script><meta property="og:title" content="5 Reasons to Use Typealias"><meta property="og:description" content="Swift has many features that allow us as the users of the language to customize how we write code, while still giving us all the protections of a statically typed language. Today we&rsquo;re going to talk about one of those features which seems small, but it packs a lot of punch.
The typealias keyword lets you define a &ldquo;type alias&rdquo;, a custom name for a class, struct or any other existing type in Swift."><meta property="og:type" content="article"><meta property="og:url" content="https://dillon-mce.com/posts/reasons-to-use-typealias/"><meta property="og:image" content="https://dillon-mce.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-05-25T00:00:00+00:00"><meta property="article:modified_time" content="2022-05-25T00:00:00+00:00"><meta property="og:site_name" content="Develop with Dillon"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://dillon-mce.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="5 Reasons to Use Typealias"><meta name=twitter:description content="Swift has many features that allow us as the users of the language to customize how we write code, while still giving us all the protections of a statically typed language. Today we&rsquo;re going to talk about one of those features which seems small, but it packs a lot of punch.
The typealias keyword lets you define a &ldquo;type alias&rdquo;, a custom name for a class, struct or any other existing type in Swift."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://dillon-mce.com/posts/"},{"@type":"ListItem","position":3,"name":"5 Reasons to Use Typealias","item":"https://dillon-mce.com/posts/reasons-to-use-typealias/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"5 Reasons to Use Typealias","name":"5 Reasons to Use Typealias","description":"Swift has many features that allow us as the users of the language to customize how we write code, while still giving us all the protections of a statically typed language. Today we\u0026rsquo;re going to talk about one of those features which seems small, but it packs a lot of punch.\nThe typealias keyword lets you define a \u0026ldquo;type alias\u0026rdquo;, a custom name for a class, struct or any other existing type in Swift.","keywords":["Swift"],"articleBody":"Swift has many features that allow us as the users of the language to customize how we write code, while still giving us all the protections of a statically typed language. Today we’re going to talk about one of those features which seems small, but it packs a lot of punch.\nThe typealias keyword lets you define a “type alias”, a custom name for a class, struct or any other existing type in Swift. Once you declare it you can use that new name anywhere you would have used the name of the original type.\ntypealias NewName = ExistingType let newName = NewName() // the type of newName will actually be ExistingType Simple, right? Basically you can give your type a nickname.\nReasons to use it We’ve all had nicknames and used them for our friends and family, but unlike your childhood nicknames, type aliases can provide a lot of benefit to you as a developer. Here’s a list of the top five.\n1. Clarity One use for type aliases is to add clarity around what a type is used for. Double is a primitive type in Swift and it can be used in any number of ways, but when it is used in the context of dates and times it might be good to add a little more explanation about what we mean with the value. Foundation does exactly that by adding a type alias called TimeInterval and documenting that “A TimeInterval value is always specified in seconds…”.\nAnother good example comes from handling money. It is relatively common practice when dealing with money in code is to multiply the value by 100 and work with it as Int values to avoid rounding errors. If that is what you’re doing, you might add some clarity to your code by adding a Cents type alias to communicate what you mean with the Int value.\n/// Describes the value of one-hundreth (1/100) of a dollar (USD). typealias Cents = Int struct Product { let name: String let price: Cents } func buy(product: Product, currentBalance: Cents) throws { guard currentBalance \u003e product.price else { throw .NotEnoughMoney } currentBalance -= product.price currentUser.add(product) } That’s a lot clearer than having Int all over the place and either adding comments to describe the meaning or assuming that the reader knows what it means. (You know what happens when you assume.)\n2. Brevity Another use is to take a long name and make it shorter. If you’ve ever worked with AVFoundation for instance, you’ll know that there are some incredibly long delegate names out there (e.g. AVCaptureFileOutputRecordingDelegate) and it can be nice to provide a short alternative. Or maybe you are trying to keep the line width to a reasonable limit and the completion handler definition is too long to fit.\n// Say you have this function that you are trying to make shorter private func fetchFavorites(type: ItemType, completion: @escaping (Result\u003c[Item], Error\u003e) -\u003e Void) // you can typealias the result type typealias ItemResult = Result\u003c[Item], Error\u003e // and you can typealias the closure type typealias ItemHandler = (ItemResult) -\u003e Void // then your function could look like this private func fetchFavorites(type: ItemType, completion: @escaping ItemHandler) Much shorter! Taking 98 characters down to 78.\n3. DRY (Don’t Repeat Yourself) That leads to another good reason to use typealias. If you define a type alias for a specific result type, you can reuse that everywhere you need that result type. Maybe you have a function that gets all the items of a type, or all the items that belong to a user. Both of those could use this same type alias.\nprivate func fetchAll(type: ItemType, completion: @escaping ItemHandler) private func fetchAll(for user: User, compeltion: @escaping ItemHandler) On top of that, the alias in this context makes it easier to make changes down the line. Maybe your backend folks want to change the returned result from an array of items to an object that contains some other information alongside the array. All you need to do is update the type alias and the compiler will then show you where you need to handle it.\ntypealias ItemResult = Result 4. Combine Protocols You can also use typealias to combine multiple protocols into one name. You may want to do this if you have multiple protocols that are commonly used together, but that define methods that aren’t required to be handled by the same type. A good example of this from Foundation is Codable, which is really just a type alias for Decodable and Encodable. This way if your type can just be encodable or decodable if you only need the functionality of one or the other, or it can be both by adopting the one protocol.\nMaybe in your code the UICollectionViewDelegate and UICollectionViewDataSource are always the same object. You could define a type alias to encompass both. Same for UICollectionViewDragDelegate and UICollectionViewDropDelegate.\ntypealias CollectionViewDataSourceDelegate = UICollectionViewDataSource \u0026 UICollectionViewDelegate typealias CollectionViewDragDropDelegate = UICollectionViewDragDelegate \u0026 UICollectionViewDropDelegate typealias CollectionViewSuperDelegate = CollectionViewDataSourceDelegate \u0026 CollectionViewDragDropDelegate // Use the type alias that combines them all class ViewController: CollectionViewSuperDelegate { override func viewDidLoad { super.viewDidLoad() // and then this type can be all four of these things collectionView.dataSource = self collectionView.delegate = self collectionView.dragDelegate = self collectionView.dropDelegate = self } } 5. Better Auto-complete Finally, if you’re lazy like me and rely on auto-complete to do most of your typing for you, you’re in luck. Type aliases will show up there and definitely speed things up when they are specifying a generic type. ItemResult will auto-complete as a whole unit, but Result\u003c[Item], Error\u003e would take more keystrokes because you would either have to auto-complete Result, Item and Error separately, or just type it all out yourself.\nBonus. Light-weight Type Replacement With a type alias, you can name a tuple with labels and it will basically function as a struct without a lot of the bells and whistles. I would not recommend doing this in production. It can be helpful when you’re prototyping, messing around with a script or maybe in a test suite. But in almost all cases you should turn your prototype into a real struct, or pick an existing type that fits the shape of your data, before pushing your code to production.\n// this is valid Swift // you can name this tuple typealias Coordinate = (x: Int, y: Int) // use it as a parameter in your functions func manhattanDistance(from first: Coordinate, to second: Coordinate) -\u003e Int { return abs(first.x - second.x) + abs(first.y - second.y) } // and pass literal tuples to that function manhattanDistance(from: (1,2), to: (3,4)) // results in 4 // but there is already a common type in most contexts where you write Swift // called CGPoint that you should probably use instead func manhattanDistance(from first: CGPoint, to second: CGPoint) -\u003e CGFloat {…} Why You (Mostly) Shouldn’t Use It Type aliases are very useful and there are many good reasons to use them, but that doesn’t mean you should rename every type in your code. So next time you’re going to reach for it, be sure to weigh the cost against the benefits.\nType aliases add complexity to your code. Mental overhead. Any time a reader of your code (including future you) comes across an alias they will either have to option+click it in Xcode to see what it actually is, or they will have to switch it out for the real meaning in their head. If it is the first time they have encountered it, they may have to look up the actual definition several times before they internalize it. Sometimes this trade off is worth it, if you are reaping the benefits of one or more reasons listed above. But other times it is not.\nYou might find yourself in a situation where you want to rename something because of your preference, but you won’t actually benefit from it, or the benefit is so small that it isn’t worth the added complexity. I would advise against using a type alias in this case. Especially if you work on a codebase with a team larger than just you. It actually makes your code harder to read. And that is almost never a good thing.\n// this alias actually reduces clarity _and_ brevity typealias Number = Int // this one adds brevity but reduces clarity typealias TableController = UITableViewController // these don't add much benefit and are kind of the opposite of dry typealias StringArray = Array typealias IntArray = Array typealias DoubleArray = Array The cost gets even higher if you and/or your team spend a lot of time looking at your code outside of Xcode. If you have a regular code review process (you should) there is a good chance that significant amounts of time will be spent reading and reasoning about code for the first time from the GitHub/GitLab/Bitbucket/etc diff interface where you don’t have the convenience of being able to option-click a type name to see its definition. There are times when the trade off is still worth it, but it is good to have a conversation with your team about what your collective line is, or to follow the established practice if it exists.\nWrap Up Type aliases are just one of the many features of Swift that makes it really customizable and extensible while still being totally type-safe. We’ve covered some of the many good reasons to use them, including adding clarity, reducing line-length, reducing unnecessary repetition, combining protocols, and improving auto-complete. And we’ve talked about how type aliases always come at the cost of added complexity, so we should weigh the cost against the benefit before we use them.\nWhat do you think? When do you use type aliases in your code? What makes the trade off worth it for you?\n","wordCount":"1631","inLanguage":"en","datePublished":"2022-05-25T00:00:00Z","dateModified":"2022-05-25T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://dillon-mce.com/posts/reasons-to-use-typealias/"},"publisher":{"@type":"Organization","name":"Develop with Dillon","logo":{"@type":"ImageObject","url":"https://dillon-mce.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://dillon-mce.com accesskey=h title="Devlop with Dillon (Alt + H)"><img src=https://dillon-mce.com/apple-touch-icon.png alt=logo aria-label=logo height=35>Devlop with Dillon</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://dillon-mce.com/ title=Home><span>Home</span></a></li><li><a href=https://dillon-mce.com/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://dillon-mce.com/cv title=CV><span>CV</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>5 Reasons to Use Typealias</h1><div class=post-meta><span title='2022-05-25 00:00:00 +0000 UTC'>May 25, 2022</span>&nbsp;·&nbsp;8 min&nbsp;|&nbsp;<a class=muted href=https://github.com/dillon-mce/dillon-mce.github.io/blob/main/content/posts/reasons-to-use-typealias.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><p>Swift has many features that allow us as the users of the language to customize how we write code, while still giving us all the protections of a statically typed language. Today we&rsquo;re going to talk about one of those features which seems small, but it packs a lot of punch.</p><p>The <code>typealias</code> keyword lets you define a &ldquo;type alias&rdquo;, a custom name for a class, struct or any other existing type in Swift. Once you declare it you can use that new name anywhere you would have used the name of the original type.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>typealias</span> NewName = ExistingType
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> newName = NewName() <span style=color:#75715e>// the type of newName will actually be ExistingType</span>
</span></span></code></pre></div><p>Simple, right? Basically you can give your type a nickname.</p><h2 id=reasons-to-use-it>Reasons to use it<a hidden class=anchor aria-hidden=true href=#reasons-to-use-it>#</a></h2><p>We&rsquo;ve all had nicknames and used them for our friends and family, but unlike your childhood nicknames, type aliases can provide a lot of benefit to you as a developer. Here&rsquo;s a list of the top five.</p><h3 id=1-clarity>1. Clarity<a hidden class=anchor aria-hidden=true href=#1-clarity>#</a></h3><p>One use for type aliases is to add clarity around what a type is used for. <code>Double</code> is a primitive type in Swift and it can be used in any number of ways, but when it is used in the context of dates and times it might be good to add a little more explanation about what we <em>mean</em> with the value. Foundation does exactly that by adding a type alias called <code>TimeInterval</code> and documenting that &ldquo;A <code>TimeInterval</code> value is always specified in seconds…&rdquo;.</p><p>Another good example comes from handling money. It is relatively common practice when dealing with money in code is to multiply the value by 100 and work with it as <code>Int</code> values to avoid rounding errors. If that is what you&rsquo;re doing, you might add some clarity to your code by adding a <code>Cents</code> type alias to communicate what you mean with the <code>Int</code> value.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#75715e>/// Describes the value of one-hundreth (1/100) of a dollar (USD).</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>typealias</span> Cents = Int
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Product</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>let</span> name: String
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>let</span> price: Cents
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>buy</span>(product: Product, currentBalance: Cents) <span style=color:#66d9ef>throws</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>guard</span> currentBalance <span style=color:#f92672>&gt;</span> product.price <span style=color:#66d9ef>else</span> { <span style=color:#66d9ef>throw</span> .NotEnoughMoney }
</span></span><span style=display:flex><span>	currentBalance <span style=color:#f92672>-=</span> product.price
</span></span><span style=display:flex><span>	currentUser.add(product)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>That&rsquo;s a lot clearer than having <code>Int</code> all over the place and either adding comments to describe the meaning or assuming that the reader knows what it means. (You know <a href=https://media.giphy.com/media/l1J9yApnGts8EXYoo/giphy-downsized-large.gif>what happens when you assume.</a>)</p><h3 id=2--brevity>2. Brevity<a hidden class=anchor aria-hidden=true href=#2--brevity>#</a></h3><p>Another use is to take a long name and make it shorter. If you&rsquo;ve ever worked with <code>AVFoundation</code> for instance, you&rsquo;ll know that there are some incredibly long delegate names out there (e.g. <code>AVCaptureFileOutputRecordingDelegate</code>) and it can be nice to provide a short alternative. Or maybe you are trying to keep the line width to a reasonable limit and the completion handler definition is too long to fit.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#75715e>// Say you have this function that you are trying to make shorter</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>fetchFavorites</span>(type: ItemType, completion: @escaping (Result<span style=color:#f92672>&lt;</span>[Item], Error&gt;) -&gt; Void)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// you can typealias the result type</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>typealias</span> ItemResult = Result<span style=color:#f92672>&lt;</span>[Item], Error&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// and you can typealias the closure type</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>typealias</span> ItemHandler = (ItemResult) -&gt; Void
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// then your function could look like this</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>fetchFavorites</span>(type: ItemType, completion: @escaping ItemHandler)
</span></span></code></pre></div><p>Much shorter! Taking 98 characters down to 78.</p><h3 id=3-dry-dont-repeat-yourself>3. DRY (Don&rsquo;t Repeat Yourself)<a hidden class=anchor aria-hidden=true href=#3-dry-dont-repeat-yourself>#</a></h3><p>That leads to another good reason to use <code>typealias</code>. If you define a type alias for a specific result type, you can reuse that everywhere you need that result type. Maybe you have a function that gets <em>all</em> the items of a type, or <em>all</em> the items that belong to a user. Both of those could use this same type alias.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>fetchAll</span>(type: ItemType, completion: @escaping ItemHandler)
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>fetchAll</span>(<span style=color:#66d9ef>for</span> user: User, compeltion: @escaping ItemHandler)
</span></span></code></pre></div><p>On top of that, the alias in this context makes it easier to make changes down the line. Maybe your backend folks want to change the returned result from an array of items to an object that contains some other information alongside the array. All you need to do is update the type alias and the compiler will then show you where you need to handle it.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>typealias</span> ItemResult = Result&lt;ItemResponse, Error&gt;
</span></span></code></pre></div><h3 id=4-combine-protocols>4. Combine Protocols<a hidden class=anchor aria-hidden=true href=#4-combine-protocols>#</a></h3><p>You can also use <code>typealias</code> to combine multiple protocols into one name. You may want to do this if you have multiple protocols that are commonly used together, but that define methods that aren&rsquo;t required to be handled by the same type. A good example of this from Foundation is <code>Codable</code>, which is really just a type alias for <code>Decodable</code> and <code>Encodable</code>. This way if your type can just be encodable or decodable if you only need the functionality of one or the other, or it can be <em>both</em> by adopting the one protocol.</p><p>Maybe in your code the <code>UICollectionViewDelegate</code> and <code>UICollectionViewDataSource</code> are always the same object. You could define a type alias to encompass both. Same for <code>UICollectionViewDragDelegate</code> and <code>UICollectionViewDropDelegate</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>typealias</span> CollectionViewDataSourceDelegate = UICollectionViewDataSource <span style=color:#f92672>&amp;</span> UICollectionViewDelegate
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>typealias</span> CollectionViewDragDropDelegate = UICollectionViewDragDelegate <span style=color:#f92672>&amp;</span> UICollectionViewDropDelegate
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>typealias</span> CollectionViewSuperDelegate = CollectionViewDataSourceDelegate <span style=color:#f92672>&amp;</span> CollectionViewDragDropDelegate
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Use the type alias that combines them all</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ViewController</span>: CollectionViewSuperDelegate {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>viewDidLoad</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>super</span>.viewDidLoad()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// and then this type can be all four of these things</span>
</span></span><span style=display:flex><span>		collectionView.dataSource = <span style=color:#66d9ef>self</span>
</span></span><span style=display:flex><span>		collectionView.delegate = <span style=color:#66d9ef>self</span>
</span></span><span style=display:flex><span>		collectionView.dragDelegate = <span style=color:#66d9ef>self</span>
</span></span><span style=display:flex><span>		collectionView.dropDelegate = <span style=color:#66d9ef>self</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=5-better-auto-complete>5. Better Auto-complete<a hidden class=anchor aria-hidden=true href=#5-better-auto-complete>#</a></h3><p>Finally, if you&rsquo;re lazy like me and rely on auto-complete to do most of your typing for you, you&rsquo;re in luck. Type aliases will show up there and definitely speed things up when they are specifying a generic type. <code>ItemResult</code> will auto-complete as a whole unit, but <code>Result&lt;[Item], Error></code> would take more keystrokes because you would either have to auto-complete <code>Result</code>, <code>Item</code> and <code>Error</code> separately, or just type it all out yourself.</p><h3 id=bonus-light-weight-type-replacement>Bonus. Light-weight Type Replacement<a hidden class=anchor aria-hidden=true href=#bonus-light-weight-type-replacement>#</a></h3><p>With a type alias, you can name a tuple with labels and it will basically function as a <code>struct</code> without a lot of the bells and whistles. <strong>I would not recommend doing this in production.</strong> It can be helpful when you&rsquo;re prototyping, messing around with a script or <em>maybe</em> in a test suite. But in almost all cases you should turn your prototype into a real <code>struct</code>, or pick an existing type that fits the shape of your data, before pushing your code to production.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#75715e>// this is valid Swift</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// you can name this tuple</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>typealias</span> Coordinate = (x: Int, y: Int)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// use it as a parameter in your functions</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>manhattanDistance</span>(from first: Coordinate, to second: Coordinate) -&gt; Int {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> abs(first.x <span style=color:#f92672>-</span> second.x) <span style=color:#f92672>+</span> abs(first.y <span style=color:#f92672>-</span> second.y)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// and pass literal tuples to that function</span>
</span></span><span style=display:flex><span>manhattanDistance(from: (<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>), to: (<span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>4</span>)) <span style=color:#75715e>// results in 4</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// but there is already a common type in most contexts where you write Swift</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// called CGPoint that you should probably use instead</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>manhattanDistance</span>(from first: CGPoint, to second: CGPoint) -&gt; CGFloat {<span style=color:#960050;background-color:#1e0010>…</span>}
</span></span></code></pre></div><h2 id=why-you-mostly-shouldnt-use-it>Why You (Mostly) Shouldn&rsquo;t Use It<a hidden class=anchor aria-hidden=true href=#why-you-mostly-shouldnt-use-it>#</a></h2><p>Type aliases are very useful and there are many good reasons to use them, but that doesn&rsquo;t mean you should rename every type in your code. So next time you&rsquo;re going to reach for it, be sure to weigh the cost against the benefits.</p><p>Type aliases add complexity to your code. Mental overhead. Any time a reader of your code (including future you) comes across an alias they will either have to option+click it in Xcode to see what it actually is, or they will have to switch it out for the real meaning in their head. If it is the first time they have encountered it, they may have to look up the actual definition several times before they internalize it. Sometimes this trade off is worth it, if you are reaping the benefits of one or more reasons listed above. But other times it is not.</p><p>You might find yourself in a situation where you want to rename something because of your preference, but you won&rsquo;t actually benefit from it, or the benefit is so small that it isn&rsquo;t worth the added complexity. I would advise against using a type alias in this case. Especially if you work on a codebase with a team larger than just you. It actually makes your code harder to read. And that is almost never a good thing.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#75715e>// this alias actually reduces clarity _and_ brevity</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>typealias</span> Number = Int
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// this one adds brevity but reduces clarity</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>typealias</span> TableController = UITableViewController
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// these don&#39;t add much benefit and are kind of the opposite of dry</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>typealias</span> StringArray = Array&lt;String&gt;
</span></span><span style=display:flex><span><span style=color:#66d9ef>typealias</span> IntArray = Array&lt;Int&gt;
</span></span><span style=display:flex><span><span style=color:#66d9ef>typealias</span> DoubleArray = Array&lt;Double&gt;
</span></span></code></pre></div><p>The cost gets even higher if you and/or your team spend a lot of time looking at your code outside of Xcode. If you have a regular code review process (you should) there is a good chance that significant amounts of time will be spent reading and reasoning about code for the first time from the GitHub/GitLab/Bitbucket/etc diff interface where you don&rsquo;t have the convenience of being able to option-click a type name to see its definition. There are times when the trade off is still worth it, but it is good to have a conversation with your team about what your collective line is, or to follow the established practice if it exists.</p><h2 id=wrap-up>Wrap Up<a hidden class=anchor aria-hidden=true href=#wrap-up>#</a></h2><p>Type aliases are just one of the many features of Swift that makes it really customizable and extensible while still being totally type-safe. We&rsquo;ve covered some of the many good reasons to use them, including adding clarity, reducing line-length, reducing unnecessary repetition, combining protocols, and improving auto-complete. And we&rsquo;ve talked about how type aliases <em>always</em> come at the cost of added complexity, so we should weigh the cost against the benefit before we use them.</p><p>What do you think? When do you use type aliases in your code? What makes the trade off worth it for you?</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://dillon-mce.com/tags/swift/>Swift</a></li></ul><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share 5 Reasons to Use Typealias on twitter" href="https://twitter.com/intent/tweet/?text=5%20Reasons%20to%20Use%20Typealias&amp;url=https%3a%2f%2fdillon-mce.com%2fposts%2freasons-to-use-typealias%2f&amp;hashtags=Swift"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 5 Reasons to Use Typealias on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fdillon-mce.com%2fposts%2freasons-to-use-typealias%2f&amp;title=5%20Reasons%20to%20Use%20Typealias&amp;summary=5%20Reasons%20to%20Use%20Typealias&amp;source=https%3a%2f%2fdillon-mce.com%2fposts%2freasons-to-use-typealias%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 5 Reasons to Use Typealias on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fdillon-mce.com%2fposts%2freasons-to-use-typealias%2f&title=5%20Reasons%20to%20Use%20Typealias"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></div></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><footer class=footer><span>&copy; 2023 <a href=https://dillon-mce.com>Dillon McElhinney</a></span></footer><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>