<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Completion Handlers in Swift | Develop with Dillon</title><meta name=keywords content="iOS,Swift"><meta name=description content="Completion handlers are everywhere in Swift. They are commonly used in Apple&rsquo;s frameworks and many third-party libraries. They are often put forward as an alternative to delegation and the target action pattern, especially in the context of long-running work like fetching data over the network or processing images. You might see them referred to as &ldquo;handlers&rdquo; or &ldquo;completion blocks&rdquo;, simply &ldquo;completions&rdquo;, or maybe something else depending on the conventions of the code base you are working in."><meta name=author content><link rel=canonical href=https://dillon-mce.com/posts/completion-handlers-in-swift/><link crossorigin=anonymous href=/assets/css/stylesheet.min.ae9017796fc0b71882930de374a7047229b17dd0004f5e7d194bd3dc1413bee5.css integrity="sha256-rpAXeW/AtxiCkw3jdKcEcimxfdAAT159GUvT3BQTvuU=" rel="preload stylesheet" as=style><link rel=icon href=https://dillon-mce.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://dillon-mce.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://dillon-mce.com/favicon-32x32.png><link rel=apple-touch-icon href=https://dillon-mce.com/apple-touch-icon.png><link rel=mask-icon href=https://dillon-mce.com/favicon-32x32.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-YZRJY88933"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-YZRJY88933")</script><meta property="og:title" content="Completion Handlers in Swift"><meta property="og:description" content="Completion handlers are everywhere in Swift. They are commonly used in Apple&rsquo;s frameworks and many third-party libraries. They are often put forward as an alternative to delegation and the target action pattern, especially in the context of long-running work like fetching data over the network or processing images. You might see them referred to as &ldquo;handlers&rdquo; or &ldquo;completion blocks&rdquo;, simply &ldquo;completions&rdquo;, or maybe something else depending on the conventions of the code base you are working in."><meta property="og:type" content="article"><meta property="og:url" content="https://dillon-mce.com/posts/completion-handlers-in-swift/"><meta property="og:image" content="https://dillon-mce.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-10-22T00:00:00+00:00"><meta property="article:modified_time" content="2022-10-22T00:00:00+00:00"><meta property="og:site_name" content="Develop with Dillon"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://dillon-mce.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Completion Handlers in Swift"><meta name=twitter:description content="Completion handlers are everywhere in Swift. They are commonly used in Apple&rsquo;s frameworks and many third-party libraries. They are often put forward as an alternative to delegation and the target action pattern, especially in the context of long-running work like fetching data over the network or processing images. You might see them referred to as &ldquo;handlers&rdquo; or &ldquo;completion blocks&rdquo;, simply &ldquo;completions&rdquo;, or maybe something else depending on the conventions of the code base you are working in."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://dillon-mce.com/posts/"},{"@type":"ListItem","position":3,"name":"Completion Handlers in Swift","item":"https://dillon-mce.com/posts/completion-handlers-in-swift/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Completion Handlers in Swift","name":"Completion Handlers in Swift","description":"Completion handlers are everywhere in Swift. They are commonly used in Apple\u0026rsquo;s frameworks and many third-party libraries. They are often put forward as an alternative to delegation and the target action pattern, especially in the context of long-running work like fetching data over the network or processing images. You might see them referred to as \u0026ldquo;handlers\u0026rdquo; or \u0026ldquo;completion blocks\u0026rdquo;, simply \u0026ldquo;completions\u0026rdquo;, or maybe something else depending on the conventions of the code base you are working in.","keywords":["iOS","Swift"],"articleBody":"Completion handlers are everywhere in Swift. They are commonly used in Apple’s frameworks and many third-party libraries. They are often put forward as an alternative to delegation and the target action pattern, especially in the context of long-running work like fetching data over the network or processing images. You might see them referred to as “handlers” or “completion blocks”, simply “completions”, or maybe something else depending on the conventions of the code base you are working in.\nToday we are going to look at what the completion handler pattern is and the main problem it solves. We’ll look at how completion handlers are actually implemented in Swift. And we’ll look at some downsides to the pattern and some examples of how to work around them.\nWhat Is A Completion Handler? At the most basic level, a completion handler is a block of work that is passed as an argument to a function so that it can run at a later time. There are many reasons why we might want to use them, but they are especially powerful when we have a task that will take a long time to finish and we don’t want that task to block other work. That’s a pretty abstract sentence, so let’s think through an example.\nImagine a user taps a button in your app that is supposed to load some data. Let’s say it is a list of pets who need to be adopted in the zip code the user entered. (It doesn’t matter what the data is, but why not imagine cute animals?) The button tap will be handled on the main thread (which is used for all UI updates on iOS) and that will kick off a network request to load the data, and when that returns it will update the UI to show the list of adorable pets. The simplest way to code this would be to just kick off the network request and then sit and wait for it to return and then update the UI when it does.\nBut what if that request took 2 seconds? or 5 seconds? The user wouldn’t be able to do anything while they waited. They couldn’t navigate around the rest of the app, they couldn’t scroll or tap any other buttons or anything else, because that is all code that has to run and we’re already waiting for the network request to return. We’re blocking other work. That is a terrible user experience.\nWe have very little control over how long that network request will take, but we can improve the UX here. Instead of waiting, we’ll put the work that takes a long time (in this case the network request) on another thread that won’t block our UI thread. (Pretty much all of the abstractions that are used for network requests on iOS do exactly that for us under the hood.) That solves the problem of blocking the user from being able to use the app. But what about when the data comes back? How do we get that data to show up in our UI?\nThat is where completion handlers come in. When we kick off the network request in the first place, we’ll give it a completion handler – block of work to run once the request returns. We’ll trigger our UI update in that block of work.\nNow that we have a high-level idea of what a completion handler is and what problem they solve, let’s dig into what they actually look like in Swift. To do that, we need to look at the concept of closures as a whole and a little bit about their semantics.\nA Brief Diversion On Closures As the Swift Language Guide says:\nClosures are self-contained blocks of functionality that can be passed around and used in your code.\nIn other languages you might see them referred to as “blocks” or “lambdas”, but in Swift the name comes from their ability to capture or “close over” constants and variables in the context where they are defined. We’ll touch on that more in a minute.\nSo a closure is a block of code that can take arguments and returns some value. Sounds a lot like a function, right? That’s because in Swift functions are actually a specialized type of closure. They have a name and some special syntax, but you can pass a function anywhere you can pass a closure. Just as long as the signature matches.\nThat means a function which takes a completion handler is actually a closure that takes another closure to run at some later point. It’s closures all the way down! This is usually where I see people’s eyes start to glaze over, but it is worth understanding if you can stick with it.\nIn Swift these are all closures, and they would all do the same thing:\nfunc firstAdd(_ a: Int, _ b: Int) -\u003e Int { return a + b } let secondAdd: (Int, Int) -\u003e Int = { a, b in return a + b } let thirdAdd = { (a: Int, b: Int) -\u003e Int in return a + b } let fourthAdd: (Int, Int) -\u003e Int = { $0 + $1 } The first one is a normal function that you are probably used to seeing. The second defines the signature of the closure and then the closure itself, giving names (“a” and “b”) to the arguments. The third defines the signature and names together within the closure. The fourth uses the anonymous argument labels (\"$0\" meaning the first argument, “$1” meaning the second, and so on) and omits the return keyword, which is allowed because this is a one line closure and the return value can be inferred as the result of that line.\nIf you wanted to add two values you could call any of these in the same way:\nfirstAdd(2, 2) secondAdd(2, 2) thirdAdd(2, 2) fourthAdd(2, 2) Capturing Values This is great if you have the values you want to pass to the closure and the logic is trivial like it is here. But what if we want to keep track of some state beyond an individual run of the closure? That is where capturing variables comes in. Let’s say we have a game and we’re keeping track of a score for a given user. We might model our logic like this:\n// simple object to encapsulate different difficulties in our game struct Difficulty { let pointValue: Int static let easy = Difficulty(pointValue: 10) static let hard = Difficulty(pointValue: 6) } // global function for generating a new counter of a given difficulty func scoreCounter(diffculty: Difficulty = .easy) -\u003e () -\u003e Int { var score: Int = 0 let adder: () -\u003e Int = { score += diffculty.pointValue return score } return adder } let easyCounter = scoreCounter() print(easyCounter()) // 10 print(easyCounter()) // 20 let hardCounter = scoreCounter(diffculty: .hard) print(hardCounter()) // 6 print(hardCounter()) // 12 Look at the scoreCounter function. We are going to give it a Difficulty and it is going to give us a closure which takes no value and returns an Int. Internally, it declares a variable called score and sets it to 0. Then it makes a closure called adder which itself adds the difficulty’s pointValue to the score and then returns the new score. Finally, it returns the adder.\nThe magic here is that the closure “captures” a reference to the score variable and also to the difficulty’s pointValue. So it will actually increase each time we call the closure, even though we’re not holding onto that score variable anywhere. And each instance of the counter will have its own score variable.\nEscaping This may not seem like much, and in all honesty, it is probably not the best way to model a score counter, but when we combine it with the next feature of closures we start to see where it all comes together. Closures can also “escape” the scope where they are passed.\nThat means they can outlive the scope of where they are passed. This is a fairly confusing concept, but it basically boils down to a function (A) saying that the closure it accepts (B) may run after the function has returned (C). In our score counter example it might look like this:\n// A. func scoreCounter(modify: @escaping (Int) -\u003e Int) -\u003e (Int) -\u003e Int { var score: Int = 0 let adder: (Int) -\u003e Int = { score += modify($0) // C. return score } return adder } let modify: (Int) -\u003e Int = { $0 * 8 / 10 } // B. let customCounter = scoreCounter(modify: modify) print(customCounter(10)) // 8 print(customCounter(10)) // 16 The scoreCounter function takes a modify closure and it is going to build an adder closure to return. Since the modify closure it takes as an argument is going to be called by the adder closure it returns, it may be called after scoreCounter has finished its work, so we have to mark it as @escaping.\nBack To Completion Handlers So for our example we might write something like this, with a completion handler:\nfunc fetchPets(then completion: @escaping ([Pet]) -\u003e Void) { ... } The caller of the function will pass a block of work that it wants to do with the fetched array of pets. Then it can continue with whatever work comes next without being blocked by the the work that needs to be done to fetch the pets. The “fetching pets work” will happen on a background thread and when it is done the “completion handler” work that the caller defined will run.\nThe the call site would look something like this:\n// in PetListViewController fetchPets { pets in self.updateUI(with: pets) } The pet list view controller says “I want to you to fetch the list of pets, and when you’re done I want you to call my update UI function with the pets that you fetched”.\nI don’t know about you, but I find that it is a lot easier to follow the logic if I personify the different classes and objects in my code and imagine them having conversations with each other.\nNow we’ve made it all the way through the diagram! We sent our long running work to a background thread where it doesn’t block the UI and we’ve used a completion handler to update our UI when it is finished. You can see that the completion handler is marked as @escaping, because it will be called after the fetchPets function has returned. And it is easy to miss, but we are actually capturing a reference to self here. The closure will hold onto a reference to the pet list view controller (which is what self refers to in this case) as long as it (the closure) remains in memory.\nIt seems like we’ve solved our problem. That’s great, but what can go wrong? Let’s look at some things you should watch out for as you use completion handlers in your code.\nSome Pitfalls UI Work On A Background Thread One of the most common mistakes I see beginners make with completion handlers is updating their UI on the background thread a network response it returned on. This usually stems from the the fact that you almost never have to dispatch your network request to a background thread in the first place (it is done for you) and so many people don’t realize their completion handler will even be called on a background thread. Plus it is easy to forget and it usually won’t lead to outright crashes, just odd behavior.\nFortunately it is relatively easy to fix. We just need to make sure the UI work runs on the UI queue. We can do that using this function called DispatchQueue.async(group:qos:flags:execute:), not to be confused with the async keyword introduced in Swift 5.5. This function takes a closure and runs it on the queue it is called on asynchronously (there is also a synchronous version called sync), with some optional configuration. In our example it would look like this:\n// in PetListViewController fetchPets { pets in DispatchQueue.main.async { self.updateUI(with: pets) } } Another tool that helps here is the “Main Thread Checker”, which you can enable in the Scheme Editor, on the “Run” tab, under “Diagnostics”. This will cause your app to pause execution when your app is running and you try to update the UI from any thread other than the main one. It will even try to show you where you’re doing it, although I find in real usage that it isn’t always 100% accurate.\nRetention Cycles Another common mistake that people make with completion handlers is causing a retain cycle. To really get to the bottom of what that means and why it can be a problem we’d have to dive deep into how Swift handles memory management. I’m not going to do that in this article, but you can read more about it here if you’re interested. For now, let’s just say that a retain cycle is when two or more objects each have a strong reference (one which adds to the retain count) to one another so that there is a closed loop of references which will hold those objects in memory indefinitely. And let’s say that is generally a bad thing that we want to avoid.\nWe can avoid that cycle if we break one of the references. In Swift we can do that with either the weak or unowned keywords. Both of these keywords will keep a reference to the object without adding to its retain count. weak references must be Optional, to acknowledge it may not be there in the future when you try to access it. unowned is similar to an implictly unwrapped optional, in that you are telling the compiler to treat the reference as always being there even though it is possible for it to not be. There are times when unowned is the right method to use, but generally speaking it is safer to use weak and that is probably what you should do unless you have a good reason to do otherwise.\nSome examples of when to use unowned would be if the captured reference will never become nil, or when the closure and the instance it captures will always refer to each other and will always be deallocated at the same time. In either of these cases though, you could use weak and it will still resolve the retain cycle it just may be slightly less performant.\nIn a closure you can make a reference weak or unowned with the “capture list”. So far when we’ve captured references in a closure it has been implicit – the compiler just handles it for us if we use a reference in the closure. But we can also explicitly capture references using the capture list. You do that by putting them in square brackets before the argument definition in the closure. That looks like this:\nfetchPets { [weak self] pets in DispatchQueue.main.async { self?.updateUI(with: pets) } } So now we are telling the compiler to keep a weak reference to self. That means self now has a type of PetListViewController? and so we use optional chaining on it before calling updateUI. If self is no longer there this block will just return. That safely avoids the retain cycle.\nYou might notice that this is the same method we use to avoid a retain cycle in the delegate pattern, it just looks a little different here because we’re using closure semantics. The main difference is that in the delegate pattern, the weak reference is handled as a part of the implementation and in the completion handler pattern it is handled at the call site. This is one reason why I generally prefer the delegate pattern. In that pattern you avoid retain cycles in one easy to check (and lint) place and users of your code don’t have to worry about it at the call site. With the completion handler pattern you give that power to the users of your method, which may be more versatile, but also means that they have to do some extra work to avoid retain cycles.\nWrap Up We’ve looked at how the completion handler pattern is just giving some other code a block of work to do later. We’ve looked at how this pattern solves the problem of not wanting to block important work in the short term with something that will take a long time. We’ve looked at the semantics and how to implement completion handlers in Swift. They may look a little funky at first, especially with some of the syntactic sugar, but they just make use of a combination of Swift features that we use elsewhere. And we’ve looked at the two main problems people run into with completion handlers – updating the UI from a background thread and inadvertently causing retain cycles – and how to avoid those problems.\n","wordCount":"2826","inLanguage":"en","datePublished":"2022-10-22T00:00:00Z","dateModified":"2022-10-22T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://dillon-mce.com/posts/completion-handlers-in-swift/"},"publisher":{"@type":"Organization","name":"Develop with Dillon","logo":{"@type":"ImageObject","url":"https://dillon-mce.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://dillon-mce.com accesskey=h title="Devlop with Dillon (Alt + H)"><img src=https://dillon-mce.com/apple-touch-icon.png alt=logo aria-label=logo height=35>Devlop with Dillon</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://dillon-mce.com/ title=Home><span>Home</span></a></li><li><a href=https://dillon-mce.com/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://dillon-mce.com/cv title=CV><span>CV</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Completion Handlers in Swift</h1><div class=post-meta><span title='2022-10-22 00:00:00 +0000 UTC'>October 22, 2022</span>&nbsp;·&nbsp;14 min&nbsp;|&nbsp;<a class=muted href=https://github.com/dillon-mce/dillon-mce.github.io/blob/main/content/posts/completion-handlers-in-swift/index.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><p>Completion handlers are everywhere in Swift. They are commonly used in Apple&rsquo;s frameworks and many third-party libraries. They are often put forward as an alternative to <a href=https://dilloncodes.com/delegate-pattern-in-swift>delegation</a> and the target action pattern, especially in the context of long-running work like fetching data over the network or processing images. You might see them referred to as &ldquo;handlers&rdquo; or &ldquo;completion blocks&rdquo;, simply &ldquo;completions&rdquo;, or maybe something else depending on the conventions of the code base you are working in.</p><p>Today we are going to look at what the completion handler pattern is and the main problem it solves. We&rsquo;ll look at how completion handlers are actually implemented in Swift. And we&rsquo;ll look at some downsides to the pattern and some examples of how to work around them.</p><h2 id=what-is-a-completion-handler>What Is A Completion Handler?<a hidden class=anchor aria-hidden=true href=#what-is-a-completion-handler>#</a></h2><p>At the most basic level, <strong>a completion handler is a block of work that is passed as an argument to a function so that it can run at a later time</strong>. There are many reasons why we might want to use them, but they are especially powerful when we have a task that will take a long time to finish and we don&rsquo;t want that task to block other work. That&rsquo;s a pretty abstract sentence, so let&rsquo;s think through an example.</p><p>Imagine a user taps a button in your app that is supposed to load some data. Let&rsquo;s say it is a list of pets who need to be adopted in the zip code the user entered. (It doesn&rsquo;t matter what the data is, but why not imagine cute animals?) The button tap will be handled on the main thread (which is used for all UI updates on iOS) and that will kick off a network request to load the data, and when that returns it will update the UI to show the list of adorable pets. The simplest way to code this would be to just kick off the network request and then sit and wait for it to return and then update the UI when it does.</p><p>But what if that request took 2 seconds? or 5 seconds? The user wouldn&rsquo;t be able to do anything while they waited. They couldn&rsquo;t navigate around the rest of the app, they couldn&rsquo;t scroll or tap any other buttons or anything else, because that is all code that has to run and we&rsquo;re already waiting for the network request to return. We&rsquo;re <strong>blocking</strong> other work. That is a terrible user experience.</p><p>We have very little control over how long that network request will take, but we can improve the UX here. Instead of waiting, we&rsquo;ll put the work that takes a long time (in this case the network request) on another thread that won&rsquo;t block our UI thread. (Pretty much all of the abstractions that are used for network requests on iOS do exactly that for us under the hood.) That solves the problem of blocking the user from being able to use the app. But what about when the data comes back? How do we get that data to show up in our UI?</p><p>That is where completion handlers come in. When we kick off the network request in the first place, we&rsquo;ll give it a completion handler – block of work to run once the request returns. We&rsquo;ll trigger our UI update in that block of work.</p><figure><img loading=lazy src=single-multi-thread.png alt="A diagram showing the difference between single and multi threaded asynchronous work over time."></figure><p>Now that we have a high-level idea of what a completion handler is and what problem they solve, let&rsquo;s dig into what they actually look like in Swift. To do that, we need to look at the concept of closures as a whole and a little bit about their semantics.</p><h2 id=a-brief-diversion-on-closures>A Brief Diversion On Closures<a hidden class=anchor aria-hidden=true href=#a-brief-diversion-on-closures>#</a></h2><p>As the <a href=https://docs.swift.org/swift-book/LanguageGuide/Closures.html>Swift Language Guide</a> says:</p><blockquote><p><em>Closures</em> are self-contained blocks of functionality that can be passed around and used in your code.</p></blockquote><p>In other languages you might see them referred to as &ldquo;blocks&rdquo; or &ldquo;lambdas&rdquo;, but in Swift the name comes from their ability to capture or &ldquo;close over&rdquo; constants and variables in the context where they are defined. We&rsquo;ll touch on that more in a minute.</p><p>So a closure is a block of code that can take arguments and returns some value. Sounds a lot like a function, right? That&rsquo;s because in Swift functions are actually a specialized type of closure. They have a name and some special syntax, but you can pass a function anywhere you can pass a closure. Just as long as the signature matches.</p><p>That means a function which takes a completion handler is actually a closure that takes another closure to run at some later point. It&rsquo;s closures all the way down! This is usually where I see people&rsquo;s eyes start to glaze over, but it is worth understanding if you can stick with it.</p><p>In Swift these are all closures, and they would all do the same thing:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>firstAdd</span>(<span style=color:#66d9ef>_</span> a: Int, <span style=color:#66d9ef>_</span> b: Int) -&gt; Int { <span style=color:#66d9ef>return</span> a <span style=color:#f92672>+</span> b }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> secondAdd: (Int, Int) -&gt; Int = { a, b <span style=color:#66d9ef>in</span> <span style=color:#66d9ef>return</span> a <span style=color:#f92672>+</span> b }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> thirdAdd = { (a: Int, b: Int) -&gt; Int <span style=color:#66d9ef>in</span> <span style=color:#66d9ef>return</span> a <span style=color:#f92672>+</span> b }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> fourthAdd: (Int, Int) -&gt; Int = { $0 <span style=color:#f92672>+</span> $1 }
</span></span></code></pre></div><p>The first one is a normal function that you are probably used to seeing. The second defines the signature of the closure and then the closure itself, giving names (&ldquo;a&rdquo; and &ldquo;b&rdquo;) to the arguments. The third defines the signature and names together within the closure. The fourth uses the anonymous argument labels ("$0" meaning the first argument, &ldquo;$1&rdquo; meaning the second, and so on) and omits the <code>return</code> keyword, which is allowed because this is a one line closure and the return value can be inferred as the result of that line.</p><p>If you wanted to add two values you could call any of these in the same way:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span>firstAdd(<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>secondAdd(<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>thirdAdd(<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>fourthAdd(<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>2</span>)
</span></span></code></pre></div><h3 id=capturing-values>Capturing Values<a hidden class=anchor aria-hidden=true href=#capturing-values>#</a></h3><p>This is great if you have the values you want to pass to the closure and the logic is trivial like it is here. But what if we want to keep track of some state beyond an individual run of the closure? That is where <em>capturing</em> variables comes in. Let&rsquo;s say we have a game and we&rsquo;re keeping track of a score for a given user. We might model our logic like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#75715e>// simple object to encapsulate different difficulties in our game</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Difficulty</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> pointValue: Int
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>let</span> easy = Difficulty(pointValue: <span style=color:#ae81ff>10</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>let</span> hard = Difficulty(pointValue: <span style=color:#ae81ff>6</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// global function for generating a new counter of a given difficulty</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>scoreCounter</span>(diffculty: Difficulty = .easy) -&gt; () -&gt; Int {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> score: Int = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> adder: () -&gt; Int = {
</span></span><span style=display:flex><span>        score <span style=color:#f92672>+=</span> diffculty.pointValue
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> score
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> adder
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> easyCounter = scoreCounter()
</span></span><span style=display:flex><span>print(easyCounter()) <span style=color:#75715e>// 10</span>
</span></span><span style=display:flex><span>print(easyCounter()) <span style=color:#75715e>// 20</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> hardCounter = scoreCounter(diffculty: .hard)
</span></span><span style=display:flex><span>print(hardCounter()) <span style=color:#75715e>// 6</span>
</span></span><span style=display:flex><span>print(hardCounter()) <span style=color:#75715e>// 12</span>
</span></span></code></pre></div><p>Look at the <code>scoreCounter</code> function. We are going to give it a <code>Difficulty</code> and it is going to give us a closure which takes no value and returns an <code>Int</code>. Internally, it declares a variable called <code>score</code> and sets it to <code>0</code>. Then it makes a closure called <code>adder</code> which itself adds the difficulty&rsquo;s <code>pointValue</code> to the <code>score</code> and then returns the new score. Finally, it returns the <code>adder</code>.</p><p>The magic here is that the closure &ldquo;captures&rdquo; a reference to the <code>score</code> variable and also to the difficulty&rsquo;s <code>pointValue</code>. So it will actually increase each time we call the closure, even though we&rsquo;re not holding onto that <code>score</code> variable anywhere. And each instance of the counter will have its own <code>score</code> variable.</p><h3 id=escaping>Escaping<a hidden class=anchor aria-hidden=true href=#escaping>#</a></h3><p>This may not seem like much, and in all honesty, it is probably not the best way to model a score counter, but when we combine it with the next feature of closures we start to see where it all comes together. Closures can also &ldquo;escape&rdquo; the scope where they are passed.</p><p>That means they can outlive the scope of where they are passed. This is a fairly confusing concept, but it basically boils down to a function (A) saying that the closure it accepts (B) may run after the function has returned (C). In our score counter example it might look like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#75715e>// A.</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>scoreCounter</span>(modify: @escaping (Int) -&gt; Int) -&gt; (Int) -&gt; Int {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> score: Int = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> adder: (Int) -&gt; Int = {
</span></span><span style=display:flex><span>        score <span style=color:#f92672>+=</span> modify($0) <span style=color:#75715e>// C.</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> score
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> adder
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> modify: (Int) -&gt; Int = { $0 <span style=color:#f92672>*</span> <span style=color:#ae81ff>8</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>10</span> } <span style=color:#75715e>// B.</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> customCounter = scoreCounter(modify: modify)
</span></span><span style=display:flex><span>print(customCounter(<span style=color:#ae81ff>10</span>)) <span style=color:#75715e>// 8</span>
</span></span><span style=display:flex><span>print(customCounter(<span style=color:#ae81ff>10</span>)) <span style=color:#75715e>// 16</span>
</span></span></code></pre></div><p>The <code>scoreCounter</code> function takes a <code>modify</code> closure and it is going to build an <code>adder</code> closure to return. Since the <code>modify</code> closure it takes as an argument is going to be called by the <code>adder</code> closure it returns, it may be called after <code>scoreCounter</code> has finished its work, so we have to mark it as <code>@escaping</code>.</p><h2 id=back-to-completion-handlers>Back To Completion Handlers<a hidden class=anchor aria-hidden=true href=#back-to-completion-handlers>#</a></h2><p>So for our example we might write something like this, with a completion handler:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>fetchPets</span>(then completion: @escaping ([Pet]) -&gt; Void) { ... }
</span></span></code></pre></div><p>The caller of the function will pass a block of work that it wants to do with the fetched array of pets. Then it can continue with whatever work comes next without being blocked by the the work that needs to be done to fetch the pets. The &ldquo;fetching pets work&rdquo; will happen on a background thread and when it is done the &ldquo;completion handler&rdquo; work that the caller defined will run.</p><p>The the call site would look something like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#75715e>// in PetListViewController</span>
</span></span><span style=display:flex><span>fetchPets { pets <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>self</span>.updateUI(with: pets)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The pet list view controller says &ldquo;I want to you to fetch the list of pets, and when you&rsquo;re done I want you to call my update UI function with the pets that you fetched&rdquo;.</p><p><em>I don&rsquo;t know about you, but I find that it is a lot easier to follow the logic if I personify the different classes and objects in my code and imagine them having conversations with each other.</em></p><p>Now we&rsquo;ve made it all the way through the diagram! We sent our long running work to a background thread where it doesn&rsquo;t block the UI and we&rsquo;ve used a completion handler to update our UI when it is finished. You can see that the completion handler is marked as <code>@escaping</code>, because it will be called after the <code>fetchPets</code> function has returned. And it is easy to miss, but we are actually capturing a reference to <code>self</code> here. The closure will hold onto a reference to the pet list view controller (which is what <code>self</code> refers to in this case) as long as it (the closure) remains in memory.</p><p>It seems like we&rsquo;ve solved our problem. That&rsquo;s great, but what can go wrong? Let&rsquo;s look at some things you should watch out for as you use completion handlers in your code.</p><h2 id=some-pitfalls>Some Pitfalls<a hidden class=anchor aria-hidden=true href=#some-pitfalls>#</a></h2><h3 id=ui-work-on-a-background-thread>UI Work On A Background Thread<a hidden class=anchor aria-hidden=true href=#ui-work-on-a-background-thread>#</a></h3><p>One of the most common mistakes I see beginners make with completion handlers is updating their UI on the background thread a network response it returned on. This usually stems from the the fact that you almost never have to dispatch your network request to a background thread in the first place (it is done for you) and so many people don&rsquo;t realize their completion handler will even be called on a background thread. Plus it is easy to forget and it usually won&rsquo;t lead to outright crashes, just odd behavior.</p><p>Fortunately it is relatively easy to fix. We just need to make sure the UI work runs on the UI queue. We can do that using this function called <code>DispatchQueue.async(group:qos:flags:execute:)</code>, not to be confused with the <code>async</code> keyword introduced in Swift 5.5. This function takes a closure and runs it on the queue it is called on asynchronously (there is also a synchronous version called <code>sync</code>), with some optional configuration. In our example it would look like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#75715e>// in PetListViewController</span>
</span></span><span style=display:flex><span>fetchPets { pets <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>	DispatchQueue.main.async { <span style=color:#66d9ef>self</span>.updateUI(with: pets) }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Another tool that helps here is the &ldquo;Main Thread Checker&rdquo;, which you can enable in the Scheme Editor, on the &ldquo;Run&rdquo; tab, under &ldquo;Diagnostics&rdquo;. This will cause your app to pause execution when your app is running and you try to update the UI from any thread other than the main one. It will even try to show you where you&rsquo;re doing it, although I find in real usage that it isn&rsquo;t always 100% accurate.</p><figure><img loading=lazy src=main-thread-checker.png alt="Screenshot showing the Main Thread Checker toggle in Xcode."></figure><h3 id=retention-cycles>Retention Cycles<a hidden class=anchor aria-hidden=true href=#retention-cycles>#</a></h3><p>Another common mistake that people make with completion handlers is causing a retain cycle. To really get to the bottom of what that means and why it can be a problem we&rsquo;d have to dive deep into how Swift handles memory management. I&rsquo;m not going to do that in this article, but you can <a href=https://docs.swift.org/swift-book/LanguageGuide/AutomaticReferenceCounting.html>read more about it here</a> if you&rsquo;re interested. For now, let&rsquo;s just say that a retain cycle is when two or more objects each have a strong reference (one which adds to the retain count) to one another so that there is a closed loop of references which will hold those objects in memory indefinitely. And let&rsquo;s say that is generally a bad thing that we want to avoid.</p><figure><img loading=lazy src=strong-reference-cycle.png alt="Diagram showing retain cycles caused by strong references."></figure><p>We can avoid that cycle if we break one of the references. In Swift we can do that with either the <code>weak</code> or <code>unowned</code> keywords. Both of these keywords will keep a reference to the object without adding to its retain count. <code>weak</code> references must be <code>Optional</code>, to acknowledge it may not be there in the future when you try to access it. <code>unowned</code> is similar to an implictly unwrapped optional, in that you are telling the compiler to treat the reference as always being there even though it is possible for it to not be. There are times when <code>unowned</code> is the right method to use, but generally speaking it is safer to use <code>weak</code> and that is probably what you should do unless you have a good reason to do otherwise.</p><figure><img loading=lazy src=weak-reference-cycle.png alt="Diagram showing retain cycles prevented by weak and unowned references."></figure><p><em>Some examples of when to use <code>unowned</code> would be if the captured reference will never become <code>nil</code>, or when the closure and the instance it captures will always refer to each other and will always be deallocated at the same time. In either of these cases though, you could use <code>weak</code> and it will still resolve the retain cycle it just may be slightly less performant.</em></p><p>In a closure you can make a reference <code>weak</code> or <code>unowned</code> with the &ldquo;capture list&rdquo;. So far when we&rsquo;ve captured references in a closure it has been implicit – the compiler just handles it for us if we use a reference in the closure. But we can also explicitly capture references using the capture list. You do that by putting them in square brackets before the argument definition in the closure. That looks like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span>fetchPets { [<span style=color:#66d9ef>weak</span> <span style=color:#66d9ef>self</span>] pets <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>	DispatchQueue.main.async { <span style=color:#66d9ef>self</span>?.updateUI(with: pets) }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>So now we are telling the compiler to keep a <code>weak</code> reference to <code>self</code>. That means <code>self</code> now has a type of <code>PetListViewController?</code> and so we use optional chaining on it before calling <code>updateUI</code>. If <code>self</code> is no longer there this block will just return. That safely avoids the retain cycle.</p><p><em>You might notice that this is the same method we use to avoid a retain cycle in the delegate pattern, it just looks a little different here because we&rsquo;re using closure semantics. The main difference is that in the delegate pattern, the <code>weak</code> reference is handled as a part of the implementation and in the completion handler pattern it is handled at the call site. This is one reason why I generally prefer the delegate pattern. In that pattern you avoid retain cycles in one easy to check (and lint) place and users of your code don&rsquo;t have to worry about it at the call site. With the completion handler pattern you give that power to the users of your method, which may be more versatile, but also means that they have to do some extra work to avoid retain cycles.</em></p><h2 id=wrap-up>Wrap Up<a hidden class=anchor aria-hidden=true href=#wrap-up>#</a></h2><p>We&rsquo;ve looked at how the completion handler pattern is just giving some other code a block of work to do later. We&rsquo;ve looked at how this pattern solves the problem of not wanting to block important work in the short term with something that will take a long time. We&rsquo;ve looked at the semantics and how to implement completion handlers in Swift. They may look a little funky at first, especially with some of the syntactic sugar, but they just make use of a combination of Swift features that we use elsewhere. And we&rsquo;ve looked at the two main problems people run into with completion handlers – updating the UI from a background thread and inadvertently causing retain cycles – and how to avoid those problems.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://dillon-mce.com/tags/ios/>iOS</a></li><li><a href=https://dillon-mce.com/tags/swift/>Swift</a></li></ul><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Completion Handlers in Swift on twitter" href="https://twitter.com/intent/tweet/?text=Completion%20Handlers%20in%20Swift&url=https%3a%2f%2fdillon-mce.com%2fposts%2fcompletion-handlers-in-swift%2f&hashtags=iOS%2cSwift"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Completion Handlers in Swift on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fdillon-mce.com%2fposts%2fcompletion-handlers-in-swift%2f&title=Completion%20Handlers%20in%20Swift&summary=Completion%20Handlers%20in%20Swift&source=https%3a%2f%2fdillon-mce.com%2fposts%2fcompletion-handlers-in-swift%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Completion Handlers in Swift on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fdillon-mce.com%2fposts%2fcompletion-handlers-in-swift%2f&title=Completion%20Handlers%20in%20Swift"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></div></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><footer class=footer><span>&copy; 2022 <a href=https://dillon-mce.com>Dillon McElhinney</a></span></footer><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>