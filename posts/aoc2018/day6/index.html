<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Advent of Code 2018 - Day 6 | Develop with Dillon</title><meta name=keywords content="Advent of Code"><meta name=description content="My understanding of Day 6’s first problem is given a list of coordinates like the one below, return an Int which is the size of the largest open area that isn’t infinite (using Manhattan or taxicab distance) around a point."><meta name=author content><link rel=canonical href=https://dillon-mce.com/posts/aoc2018/day6/><link crossorigin=anonymous href=/assets/css/stylesheet.min.ae9017796fc0b71882930de374a7047229b17dd0004f5e7d194bd3dc1413bee5.css integrity="sha256-rpAXeW/AtxiCkw3jdKcEcimxfdAAT159GUvT3BQTvuU=" rel="preload stylesheet" as=style><link rel=icon href=https://dillon-mce.com/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://dillon-mce.com/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://dillon-mce.com/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://dillon-mce.com/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://dillon-mce.com/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Advent of Code 2018 - Day 6"><meta property="og:description" content="My understanding of Day 6’s first problem is given a list of coordinates like the one below, return an Int which is the size of the largest open area that isn’t infinite (using Manhattan or taxicab distance) around a point."><meta property="og:type" content="article"><meta property="og:url" content="https://dillon-mce.com/posts/aoc2018/day6/"><meta property="og:image" content="https://dillon-mce.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-12-07T00:00:00+00:00"><meta property="article:modified_time" content="2018-12-07T00:00:00+00:00"><meta property="og:site_name" content="Develop with Dillon"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://dillon-mce.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Advent of Code 2018 - Day 6"><meta name=twitter:description content="My understanding of Day 6’s first problem is given a list of coordinates like the one below, return an Int which is the size of the largest open area that isn’t infinite (using Manhattan or taxicab distance) around a point."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://dillon-mce.com/posts/"},{"@type":"ListItem","position":3,"name":"Advent of Code 2018 - Day 6","item":"https://dillon-mce.com/posts/aoc2018/day6/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Advent of Code 2018 - Day 6","name":"Advent of Code 2018 - Day 6","description":"My understanding of Day 6’s first problem is given a list of coordinates like the one below, return an Int which is the size of the largest open area that isn’t infinite (using Manhattan or taxicab distance) around a point.","keywords":["Advent of Code"],"articleBody":"Problem 1 My understanding of Day 6’s first problem is this: given a list of coordinates like the one below, return an Int which is the size of the largest open area that isn’t infinite (using Manhattan or taxicab distance) around a point. The sample data returns 17.\n1, 1 1, 6 8, 3 3, 4 5, 5 8, 9 Method My method for solving this problem looks like this:\n Make a Point struct that has an X and Y coordinate and a method to calculate its distance from another point. Break the input into an array, and make an array of points out of it. Figure out the smallest and largest X and Y. These will be our bounds. Make an areaDict dictionary to hold the points we are given in the input as keys, and array’s of the points that belong to them as the values. Cycle through all the Xs and Ys from the smallest to the largest of each  Make another dictionary that holds each point given in the input as keys, and its distance from the current point as values Populate that dictionary with the distances Find the smallest distance, and if there is only one, add the point to the areaDict dictionary   Filter the area dictionary to get rid of any that point that has values which touch the bounds. Those are infinite. Find the biggest value in the filtered dictionary and return the count of its points.  Implementation My Point struct looks like this:\nstruct Point: Hashable {  var x: Int  var y: Int   func calculateDistance(from point: Point) - Int {  return abs(self.x - point.x) + abs(self.y - point.y)  } } It is Hashable so that I can make it the key in a dictionary, and it has variables for the X value and the Y value of the point. calculateDistance() takes a point and calculates the Manhattan or taxicab distance from the point. The equation for that is the absolute value of X1 - X2 plus the absolute value of Y1 - Y2. You can read more about it in this Wikipedia article .\nMy parseInput() function looks like this:\nfunc parseInput(_ string: String) - [Point] {  let array = string.components(separatedBy: CharacterSet(charactersIn: \"\\n\"))   let pointArray = array.compactMap() { string - Point? in  let array = string.components(separatedBy: .punctuationCharacters).joined().components(separatedBy: .whitespaces)  guard array.count  1, let x = Int(array[0]), let y = Int(array[1]) else { return nil }  let point = Point(x: x, y: y)  return point  }   return pointArray } I first split up the input string into an array of each line and then I make an array of Points by calling compactMap() on that array. Inside of the closure, I try to pull out the X and Y values and make Ints out of them, if that doesn’t work, I just skip that line by returning nil. This works here because the input data is perfectly uniform. If I am able to get the values, I make a Point out of them and return it.\nThe first part of my main function looks like this:\nlet pointArray = parseInput(string)  guard let maxX = pointArray.max(by: { $0.x  $1.x }), let maxY = pointArray.max(by: { $0.y  $1.y }), let minX = pointArray.min(by: { $0.x  $1.x }), let minY = pointArray.min(by: { $0.y  $1.y }) else { return -1 } I get an array of Points by calling the parseInput() function. After that, I pull out the smallest and largest X, and the smallest and largest Y. That gives me the bounds of the grid that we care about.\nThe main part of the function looks like this:\nvar areaDict: [Point: [Point]] = [:] for x in minX.x...maxX.x {  for y in minY.y...maxY.y {  var distanceDict: [Point: Int] = [:]  let testPoint = Point(x: x, y: y)  for point in pointArray {  distanceDict[point] = point.calculateDistance(from: testPoint)  }  if let min = distanceDict.min(by: { $0.value  $1.value }) {  if distanceDict.values.filter({ $0 == min.value }).count == 1 {  areaDict[min.key, default: []].append(testPoint)  }  }  } } First, I make a dictionary to hold each point from the input data, and an array of points that it is closest to. Then I loop through all of the Xs and Ys that we care about (the ones inside the bounds), make a Point out of each, and a dictionary to hold its distance to each of the input points. Then I calculate the distance to each of the input points and store them in that dictionary. Finally, I find the smallest distance in that dictionary and if there is only one Point that is that distance, add the Point we’re currently checking to the array in the areaDict at the Point it is closest to.\nFinally, after populating the areaDict, the rest of the function looks like this:\nlet filteredDict = areaDict.filter { (key: Point, value: [Point]) - Bool in  let array = value.filter() {  return $0.x == minX.x || $0.x == maxX.x || $0.y == minY.y || $0.y == maxY.y  }  return !(array.count  0)  }   let biggestArea = filteredDict.max(by: { $0.value.count  $1.value.count })  return biggestArea?.value.count ?? -1 I get a new dictionary which is areaDict filtered of all the input Points that have any closest Points that touch the bounds, because that means they are infinite on this grid. I then find the input Point that has the largest count of points (i.e. area) and then return that value. I use the nil coalescing operator because biggestArea is optional, and that was the easiest/ fastest way to unwrap it. I return -1 as the default because that will never be a value the function should produce so it will be a sign to me that something has gone wrong.\nThe answer for my input was 4398 and it takes about 3.5 seconds to calculate on the command line using the method described in my AoC Setup post.\nProblem 2 I would describe the second problem like this: given the same list of coordinates, return an Int which is the total area in which each Point’s distance from all of the given coordinates adds up to something less than a given target value. The sample data returns 16 with a target value of 32.\nMethod This is how I solved this problem:\n Get an array of Points and find the bounds the same as before. Make a Set of Points that will hold all of the “safe points” Cycle through each X and Y within the bounds and check if they are “safe” by adding up its distances from each of the input Points. If they are safe, add them to the set. Return the count of safe points.  Implementation I used the same Point and parseInput() function as before, and the first few lines of my main function for this part is identical to the main function from the first part, except that I wrote this function to take in a targetValue which is an Int, so that I could test against the sample data and my input data with different target values.\nThe section that is different looks like this:\nvar safePoints: Set = Set() for x in minX.x...maxX.x {  for y in minY.y...maxY.y {  var distanceDict: [Point: Int] = [:]  let testPoint = Point(x: x, y: y)  for point in pointArray {  distanceDict[point] = point.calculateDistance(from: testPoint)  }  let sum = distanceDict.values.reduce(0, +)  if sum  targetValue {  safePoints.insert(testPoint)  }  } }  return safePoints.count First, I make a Set to hold the safe points and set it to an empty Set. Then I loop through all the Xs and Ys in the bounds, make a Point out of each one and a dictionary to hold the distances from each of the input Points. Then I just reduce that dictionary to a single value and if it is less than the targetValue I insert the point into the safePoints set. At the end, I return the count of points.\nThe answer for my input with a target value of 10,000 is 39560 and it takes about 2.5 seconds to calculate on the command line.\nReflections  This was another interesting geometrical problem. Lots of practice keeping track of and comparing coordinates. It also forced me to think a little abstractly about the bounds to the grid and how to tell if a certain point was closest to an infinite number of points or not.  You can find all the code for my attempts so far in my advent of code 2018 repository on GitHub.\n","wordCount":"1421","inLanguage":"en","datePublished":"2018-12-07T00:00:00Z","dateModified":"2018-12-07T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://dillon-mce.com/posts/aoc2018/day6/"},"publisher":{"@type":"Organization","name":"Develop with Dillon","logo":{"@type":"ImageObject","url":"https://dillon-mce.com/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://dillon-mce.com accesskey=h title="Devlop with Dillon (Alt + H)"><img src=https://dillon-mce.com/apple-touch-icon.png alt=logo aria-label=logo height=35>Devlop with Dillon</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://dillon-mce.com/ title=Home><span>Home</span></a></li><li><a href=https://dillon-mce.com/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://dillon-mce.com/cv title=CV><span>CV</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Advent of Code 2018 - Day 6</h1><div class=post-meta><span title="2018-12-07 00:00:00 +0000 UTC">December 7, 2018</span>&nbsp;·&nbsp;7 min&nbsp;|&nbsp;<a class=muted href=https://github.com/dillon-mce/dillon-mce.github.io/blob/main/content/posts/2018-12-07-Advent-of-Code-2018-Day-6.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><h2 id=problem-1httpsadventofcodecom2018day6><a href=https://adventofcode.com/2018/day/6>Problem 1</a><a hidden class=anchor aria-hidden=true href=#problem-1httpsadventofcodecom2018day6>#</a></h2><p>My understanding of Day 6’s first problem is this: given a list of coordinates like the one below, return an Int which is the size of the largest open area that isn’t infinite (using Manhattan or taxicab distance) around a point. The sample data returns 17.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>1, 1
</span></span><span style=display:flex><span>1, 6
</span></span><span style=display:flex><span>8, 3
</span></span><span style=display:flex><span>3, 4
</span></span><span style=display:flex><span>5, 5
</span></span><span style=display:flex><span>8, 9
</span></span></code></pre></div><h3 id=method>Method<a hidden class=anchor aria-hidden=true href=#method>#</a></h3><p>My method for solving this problem looks like this:</p><ul><li>Make a Point struct that has an X and Y coordinate and a method to calculate its distance from another point.</li><li>Break the input into an array, and make an array of points out of it.</li><li>Figure out the smallest and largest X and Y. These will be our bounds.</li><li>Make an <code>areaDict</code> dictionary to hold the points we are given in the input as keys, and array’s of the points that belong to them as the values.</li><li>Cycle through all the Xs and Ys from the smallest to the largest of each<ul><li>Make another dictionary that holds each point given in the input as keys, and its distance from the current point as values</li><li>Populate that dictionary with the distances</li><li>Find the smallest distance, and if there is only one, add the point to the <code>areaDict</code> dictionary</li></ul></li><li>Filter the area dictionary to get rid of any that point that has values which touch the bounds. Those are infinite.</li><li>Find the biggest value in the filtered dictionary and return the count of its points.</li></ul><h3 id=implementation>Implementation<a hidden class=anchor aria-hidden=true href=#implementation>#</a></h3><p>My <code>Point</code> struct looks like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Point</span>: Hashable {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> x: Int
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> y: Int
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>calculateDistance</span>(from point: Point) -&gt; Int {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> abs(<span style=color:#66d9ef>self</span>.x <span style=color:#f92672>-</span> point.x) <span style=color:#f92672>+</span> abs(<span style=color:#66d9ef>self</span>.y <span style=color:#f92672>-</span> point.y)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>It is Hashable so that I can make it the key in a dictionary, and it has variables for the X value and the Y value of the point. <code>calculateDistance()</code> takes a point and calculates the Manhattan or taxicab distance from the point. The equation for that is the absolute value of X1 - X2 plus the absolute value of Y1 - Y2. You can read more about it in <a href=https://en.wikipedia.org/wiki/Taxicab_geometry>this Wikipedia article</a> .</p><p>My <code>parseInput()</code> function looks like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>parseInput</span>(<span style=color:#66d9ef>_</span> string: String) -&gt; [Point] {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> array = string.components(separatedBy: CharacterSet(charactersIn: <span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> pointArray = array.compactMap() { string -&gt; Point? <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> array = string.components(separatedBy: .punctuationCharacters).joined().components(separatedBy: .whitespaces)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>guard</span> array.count <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>1</span>, <span style=color:#66d9ef>let</span> x = Int(array[<span style=color:#ae81ff>0</span>]), <span style=color:#66d9ef>let</span> y = Int(array[<span style=color:#ae81ff>1</span>]) <span style=color:#66d9ef>else</span> { <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span> }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> point = Point(x: x, y: y)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> point
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> pointArray
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>I first split up the input string into an array of each line and then I make an array of Points by calling <code>compactMap()</code> on that array. Inside of the closure, I try to pull out the X and Y values and make Ints out of them, if that doesn’t work, I just skip that line by returning nil. This works here because the input data is perfectly uniform. If I am able to get the values, I make a Point out of them and return it.</p><p>The first part of my main function looks like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>let</span> pointArray = parseInput(string)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>guard</span> <span style=color:#66d9ef>let</span> maxX = pointArray.max(by: { $0.x <span style=color:#f92672>&lt;</span> $1.x }), <span style=color:#66d9ef>let</span> maxY = pointArray.max(by: { $0.y <span style=color:#f92672>&lt;</span> $1.y }), <span style=color:#66d9ef>let</span> minX = pointArray.min(by: { $0.x <span style=color:#f92672>&lt;</span> $1.x }), <span style=color:#66d9ef>let</span> minY = pointArray.min(by: { $0.y <span style=color:#f92672>&lt;</span> $1.y }) <span style=color:#66d9ef>else</span> { <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span> }
</span></span></code></pre></div><p>I get an array of Points by calling the <code>parseInput()</code> function. After that, I pull out the smallest and largest X, and the smallest and largest Y. That gives me the bounds of the grid that we care about.</p><p>The main part of the function looks like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>var</span> areaDict: [Point: [Point]] = [:]
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> x <span style=color:#66d9ef>in</span> minX.x...maxX.x {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> y <span style=color:#66d9ef>in</span> minY.y...maxY.y {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> distanceDict: [Point: Int] = [:]
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> testPoint = Point(x: x, y: y)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> point <span style=color:#66d9ef>in</span> pointArray {
</span></span><span style=display:flex><span>                distanceDict[point] = point.calculateDistance(from: testPoint)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> min = distanceDict.min(by: { $0.value <span style=color:#f92672>&lt;</span> $1.value }) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> distanceDict.values.filter({ $0 == min.value }).count == <span style=color:#ae81ff>1</span> {
</span></span><span style=display:flex><span>                areaDict[min.key, <span style=color:#66d9ef>default</span>: []].append(testPoint)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>First, I make a dictionary to hold each point from the input data, and an array of points that it is closest to. Then I loop through all of the Xs and Ys that we care about (the ones inside the bounds), make a Point out of each, and a dictionary to hold its distance to each of the input points. Then I calculate the distance to each of the input points and store them in that dictionary. Finally, I find the smallest distance in that dictionary and if there is only one Point that is that distance, add the Point we’re currently checking to the array in the <code>areaDict</code> at the Point it is closest to.</p><p>Finally, after populating the <code>areaDict</code>, the rest of the function looks like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>let</span> filteredDict = areaDict.filter { (key: Point, value: [Point]) -&gt; Bool <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> array = value.filter() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> $0.x == minX.x <span style=color:#f92672>||</span> $0.x == maxX.x <span style=color:#f92672>||</span> $0.y == minY.y <span style=color:#f92672>||</span> $0.y == maxY.y
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#f92672>!</span>(array.count <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> biggestArea = filteredDict.max(by: { $0.value.count <span style=color:#f92672>&lt;</span> $1.value.count })
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>return</span> biggestArea?.value.count ?? <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>
</span></span></code></pre></div><p>I get a new dictionary which is <code>areaDict</code> filtered of all the input Points that have any closest Points that touch the bounds, because that means they are infinite on this grid. I then find the input Point that has the largest count of points (i.e. area) and then return that value. I use the nil coalescing operator because <code>biggestArea</code> is optional, and that was the easiest/ fastest way to unwrap it. I return -1 as the default because that will never be a value the function should produce so it will be a sign to me that something has gone wrong.</p><p>The answer for my input was <code>4398</code> and it takes about 3.5 seconds to calculate on the command line using the method described in <a href=https://dillon-mce.com/posts/aoc2018/setup/>my AoC Setup post</a>.</p><h2 id=problem-2httpsadventofcodecom2018day6part2><a href=https://adventofcode.com/2018/day/6#part2>Problem 2</a><a hidden class=anchor aria-hidden=true href=#problem-2httpsadventofcodecom2018day6part2>#</a></h2><p>I would describe the second problem like this: given the same list of coordinates, return an Int which is the total area in which each Point’s distance from all of the given coordinates adds up to something less than a given target value. The sample data returns 16 with a target value of 32.</p><h3 id=method-1>Method<a hidden class=anchor aria-hidden=true href=#method-1>#</a></h3><p>This is how I solved this problem:</p><ul><li>Get an array of Points and find the bounds the same as before.</li><li>Make a Set of Points that will hold all of the “safe points”</li><li>Cycle through each X and Y within the bounds and check if they are “safe” by adding up its distances from each of the input Points.</li><li>If they are safe, add them to the set.</li><li>Return the count of safe points.</li></ul><h3 id=implementation-1>Implementation<a hidden class=anchor aria-hidden=true href=#implementation-1>#</a></h3><p>I used the same <code>Point</code> and <code>parseInput()</code> function as before, and the first few lines of my main function for this part is identical to the main function from the first part, except that I wrote this function to take in a <code>targetValue</code> which is an Int, so that I could test against the sample data and my input data with different target values.</p><p>The section that is different looks like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>var</span> safePoints: Set&lt;Point&gt; = Set()
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> x <span style=color:#66d9ef>in</span> minX.x...maxX.x {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> y <span style=color:#66d9ef>in</span> minY.y...maxY.y {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> distanceDict: [Point: Int] = [:]
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> testPoint = Point(x: x, y: y)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> point <span style=color:#66d9ef>in</span> pointArray {
</span></span><span style=display:flex><span>            distanceDict[point] = point.calculateDistance(from: testPoint)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> sum = distanceDict.values.reduce(<span style=color:#ae81ff>0</span>, <span style=color:#f92672>+</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> sum <span style=color:#f92672>&lt;</span> targetValue {
</span></span><span style=display:flex><span>            safePoints.insert(testPoint)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>return</span> safePoints.count
</span></span></code></pre></div><p>First, I make a Set to hold the safe points and set it to an empty Set. Then I loop through all the Xs and Ys in the bounds, make a Point out of each one and a dictionary to hold the distances from each of the input Points. Then I just reduce that dictionary to a single value and if it is less than the <code>targetValue</code> I insert the point into the <code>safePoints</code> set. At the end, I return the count of points.</p><p>The answer for my input with a target value of 10,000 is <code>39560</code> and it takes about 2.5 seconds to calculate on the command line.</p><h2 id=reflections>Reflections<a hidden class=anchor aria-hidden=true href=#reflections>#</a></h2><ul><li>This was another interesting geometrical problem. Lots of practice keeping track of and comparing coordinates.</li><li>It also forced me to think a little abstractly about the bounds to the grid and how to tell if a certain point was closest to an infinite number of points or not.</li></ul><p>You can find all the code for my attempts so far in <a href=https://github.com/dillon-mce/advent-of-code-2018>my advent of code 2018 repository on GitHub</a>.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://dillon-mce.com/tags/advent-of-code/>Advent of Code</a></li></ul><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Advent of Code 2018 - Day 6 on twitter" href="https://twitter.com/intent/tweet/?text=Advent%20of%20Code%202018%20-%20Day%206&url=https%3a%2f%2fdillon-mce.com%2fposts%2faoc2018%2fday6%2f&hashtags=AdventofCode"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Advent of Code 2018 - Day 6 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fdillon-mce.com%2fposts%2faoc2018%2fday6%2f&title=Advent%20of%20Code%202018%20-%20Day%206&summary=Advent%20of%20Code%202018%20-%20Day%206&source=https%3a%2f%2fdillon-mce.com%2fposts%2faoc2018%2fday6%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Advent of Code 2018 - Day 6 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fdillon-mce.com%2fposts%2faoc2018%2fday6%2f&title=Advent%20of%20Code%202018%20-%20Day%206"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></div></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><footer class=footer><span>&copy; 2022 <a href=https://dillon-mce.com>Dillon McElhinney</a></span></footer><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(t=>{const n=t.parentNode.parentNode,e=document.createElement("button");e.classList.add("copy-code"),e.innerHTML="copy";function s(){e.innerHTML="copied!",setTimeout(()=>{e.innerHTML="copy"},2e3)}e.addEventListener("click",o=>{if("clipboard"in navigator){navigator.clipboard.writeText(t.textContent),s();return}const e=document.createRange();e.selectNodeContents(t);const n=window.getSelection();n.removeAllRanges(),n.addRange(e);try{document.execCommand("copy"),s()}catch(e){}n.removeRange(e)}),n.classList.contains("highlight")?n.appendChild(e):n.parentNode.firstChild==n||(t.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?t.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(e):t.parentNode.appendChild(e))})</script></body></html>