<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Advent of Code 2018 - Day 4 | Develop with Dillon</title><meta name=keywords content="Advent of Code"><meta name=description content="Problem 1 My understanding of Day 4’s first problem is this: given a string like the one below, return an Int that is the minute at which the guard who spent the most total minutes asleep was asleep the most, times that guard’s ID number. The sample data returns 240. Sample data:
[1518-11-01 00:00] Guard #10 begins shift [1518-11-01 00:05] falls asleep [1518-11-01 00:25] wakes up [1518-11-01 00:30] falls asleep [1518-11-01 00:55] wakes up [1518-11-01 23:58] Guard #99 begins shift [1518-11-02 00:40] falls asleep [1518-11-02 00:50] wakes up [1518-11-03 00:05] Guard #10 begins shift [1518-11-03 00:24] falls asleep [1518-11-03 00:29] wakes up [1518-11-04 00:02] Guard #99 begins shift [1518-11-04 00:36] falls asleep [1518-11-04 00:46] wakes up [1518-11-05 00:03] Guard #99 begins shift [1518-11-05 00:45] falls asleep [1518-11-05 00:55] wakes up Method My method for solving this problem looks like this:"><meta name=author content><link rel=canonical href=https://dillon-mce.com/posts/aoc2018/day4/><link crossorigin=anonymous href=/assets/css/stylesheet.min.ae9017796fc0b71882930de374a7047229b17dd0004f5e7d194bd3dc1413bee5.css integrity="sha256-rpAXeW/AtxiCkw3jdKcEcimxfdAAT159GUvT3BQTvuU=" rel="preload stylesheet" as=style><link rel=icon href=https://dillon-mce.com/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://dillon-mce.com/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://dillon-mce.com/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://dillon-mce.com/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://dillon-mce.com/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-YZRJY88933"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-YZRJY88933")</script><meta property="og:title" content="Advent of Code 2018 - Day 4"><meta property="og:description" content="Problem 1 My understanding of Day 4’s first problem is this: given a string like the one below, return an Int that is the minute at which the guard who spent the most total minutes asleep was asleep the most, times that guard’s ID number. The sample data returns 240. Sample data:
[1518-11-01 00:00] Guard #10 begins shift [1518-11-01 00:05] falls asleep [1518-11-01 00:25] wakes up [1518-11-01 00:30] falls asleep [1518-11-01 00:55] wakes up [1518-11-01 23:58] Guard #99 begins shift [1518-11-02 00:40] falls asleep [1518-11-02 00:50] wakes up [1518-11-03 00:05] Guard #10 begins shift [1518-11-03 00:24] falls asleep [1518-11-03 00:29] wakes up [1518-11-04 00:02] Guard #99 begins shift [1518-11-04 00:36] falls asleep [1518-11-04 00:46] wakes up [1518-11-05 00:03] Guard #99 begins shift [1518-11-05 00:45] falls asleep [1518-11-05 00:55] wakes up Method My method for solving this problem looks like this:"><meta property="og:type" content="article"><meta property="og:url" content="https://dillon-mce.com/posts/aoc2018/day4/"><meta property="og:image" content="https://dillon-mce.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-12-05T00:00:00+00:00"><meta property="article:modified_time" content="2018-12-05T00:00:00+00:00"><meta property="og:site_name" content="Develop with Dillon"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://dillon-mce.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Advent of Code 2018 - Day 4"><meta name=twitter:description content="Problem 1 My understanding of Day 4’s first problem is this: given a string like the one below, return an Int that is the minute at which the guard who spent the most total minutes asleep was asleep the most, times that guard’s ID number. The sample data returns 240. Sample data:
[1518-11-01 00:00] Guard #10 begins shift [1518-11-01 00:05] falls asleep [1518-11-01 00:25] wakes up [1518-11-01 00:30] falls asleep [1518-11-01 00:55] wakes up [1518-11-01 23:58] Guard #99 begins shift [1518-11-02 00:40] falls asleep [1518-11-02 00:50] wakes up [1518-11-03 00:05] Guard #10 begins shift [1518-11-03 00:24] falls asleep [1518-11-03 00:29] wakes up [1518-11-04 00:02] Guard #99 begins shift [1518-11-04 00:36] falls asleep [1518-11-04 00:46] wakes up [1518-11-05 00:03] Guard #99 begins shift [1518-11-05 00:45] falls asleep [1518-11-05 00:55] wakes up Method My method for solving this problem looks like this:"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://dillon-mce.com/posts/"},{"@type":"ListItem","position":3,"name":"Advent of Code 2018 - Day 4","item":"https://dillon-mce.com/posts/aoc2018/day4/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Advent of Code 2018 - Day 4","name":"Advent of Code 2018 - Day 4","description":"Problem 1 My understanding of Day 4’s first problem is this: given a string like the one below, return an Int that is the minute at which the guard who spent the most total minutes asleep was asleep the most, times that guard’s ID number. The sample data returns 240. Sample data:\n[1518-11-01 00:00] Guard #10 begins shift [1518-11-01 00:05] falls asleep [1518-11-01 00:25] wakes up [1518-11-01 00:30] falls asleep [1518-11-01 00:55] wakes up [1518-11-01 23:58] Guard #99 begins shift [1518-11-02 00:40] falls asleep [1518-11-02 00:50] wakes up [1518-11-03 00:05] Guard #10 begins shift [1518-11-03 00:24] falls asleep [1518-11-03 00:29] wakes up [1518-11-04 00:02] Guard #99 begins shift [1518-11-04 00:36] falls asleep [1518-11-04 00:46] wakes up [1518-11-05 00:03] Guard #99 begins shift [1518-11-05 00:45] falls asleep [1518-11-05 00:55] wakes up Method My method for solving this problem looks like this:","keywords":["Advent of Code"],"articleBody":"Problem 1 My understanding of Day 4’s first problem is this: given a string like the one below, return an Int that is the minute at which the guard who spent the most total minutes asleep was asleep the most, times that guard’s ID number. The sample data returns 240. Sample data:\n[1518-11-01 00:00] Guard #10 begins shift [1518-11-01 00:05] falls asleep [1518-11-01 00:25] wakes up [1518-11-01 00:30] falls asleep [1518-11-01 00:55] wakes up [1518-11-01 23:58] Guard #99 begins shift [1518-11-02 00:40] falls asleep [1518-11-02 00:50] wakes up [1518-11-03 00:05] Guard #10 begins shift [1518-11-03 00:24] falls asleep [1518-11-03 00:29] wakes up [1518-11-04 00:02] Guard #99 begins shift [1518-11-04 00:36] falls asleep [1518-11-04 00:46] wakes up [1518-11-05 00:03] Guard #99 begins shift [1518-11-05 00:45] falls asleep [1518-11-05 00:55] wakes up Method My method for solving this problem looks like this:\nParse the data into a dictionary with the Guard’s IDs as the key, and an array of the dates that they are asleep and awake as the value. Count up all the minutes each guard is asleep in a dictionary with their ID as the key and an Int of the count of minutes as the value. Once I find the guard who is asleep for the most minutes, need to figure out which minute they were asleep the most at. Make a dictionary of the minute as the key and an Int of the number of times the guard was asleep at that minute as the value. Loop through each minute, see if the date range contains that minute and add 1 to the associated key in the dictionary Return the minute with the largest value times the guard’s ID Implementation My function for parsing the input into a dictionary of guard ID’s and arrays of dates looks like this:\nfunc parseInput(_ string: String) -\u003e [String: [Date]] { let inputData = string.components(separatedBy: .newlines).sorted() let dateFormatter = DateFormatter() dateFormatter.dateFormat = \"yyyy-MM-dd HH:mm\" var currentGuard = \"\" var timestampDict: [String: [Date]] = [:] for i in 0..","wordCount":"1771","inLanguage":"en","datePublished":"2018-12-05T00:00:00Z","dateModified":"2018-12-05T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://dillon-mce.com/posts/aoc2018/day4/"},"publisher":{"@type":"Organization","name":"Develop with Dillon","logo":{"@type":"ImageObject","url":"https://dillon-mce.com/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://dillon-mce.com accesskey=h title="Devlop with Dillon (Alt + H)"><img src=https://dillon-mce.com/apple-touch-icon.png alt=logo aria-label=logo height=35>Devlop with Dillon</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://dillon-mce.com/ title=Home><span>Home</span></a></li><li><a href=https://dillon-mce.com/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://dillon-mce.com/cv title=CV><span>CV</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Advent of Code 2018 - Day 4</h1><div class=post-meta><span title='2018-12-05 00:00:00 +0000 UTC'>December 5, 2018</span>&nbsp;·&nbsp;9 min&nbsp;|&nbsp;<a class=muted href=https://github.com/dillon-mce/dillon-mce.github.io/blob/main/content/posts/2018-12-05-Advent-of-Code-2018-Day-4.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><h2 id=problem-1httpsadventofcodecom2018day4><a href=https://adventofcode.com/2018/day/4>Problem 1</a><a hidden class=anchor aria-hidden=true href=#problem-1httpsadventofcodecom2018day4>#</a></h2><p>My understanding of Day 4’s first problem is this: given a string like the one below, return an Int that is the minute at which the guard who spent the most total minutes asleep was asleep the most, times that guard’s ID number. The sample data returns <code>240</code>.
Sample data:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>[1518-11-01 00:00] Guard #10 begins shift
</span></span><span style=display:flex><span>[1518-11-01 00:05] falls asleep
</span></span><span style=display:flex><span>[1518-11-01 00:25] wakes up
</span></span><span style=display:flex><span>[1518-11-01 00:30] falls asleep
</span></span><span style=display:flex><span>[1518-11-01 00:55] wakes up
</span></span><span style=display:flex><span>[1518-11-01 23:58] Guard #99 begins shift
</span></span><span style=display:flex><span>[1518-11-02 00:40] falls asleep
</span></span><span style=display:flex><span>[1518-11-02 00:50] wakes up
</span></span><span style=display:flex><span>[1518-11-03 00:05] Guard #10 begins shift
</span></span><span style=display:flex><span>[1518-11-03 00:24] falls asleep
</span></span><span style=display:flex><span>[1518-11-03 00:29] wakes up
</span></span><span style=display:flex><span>[1518-11-04 00:02] Guard #99 begins shift
</span></span><span style=display:flex><span>[1518-11-04 00:36] falls asleep
</span></span><span style=display:flex><span>[1518-11-04 00:46] wakes up
</span></span><span style=display:flex><span>[1518-11-05 00:03] Guard #99 begins shift
</span></span><span style=display:flex><span>[1518-11-05 00:45] falls asleep
</span></span><span style=display:flex><span>[1518-11-05 00:55] wakes up
</span></span></code></pre></div><h3 id=method>Method<a hidden class=anchor aria-hidden=true href=#method>#</a></h3><p>My method for solving this problem looks like this:</p><ul><li>Parse the data into a dictionary with the Guard’s IDs as the key, and an array of the dates that they are asleep and awake as the value.</li><li>Count up all the minutes each guard is asleep in a dictionary with their ID as the key and an Int of the count of minutes as the value.</li><li>Once I find the guard who is asleep for the most minutes, need to figure out which minute they were asleep the most at.<ul><li>Make a dictionary of the minute as the key and an Int of the number of times the guard was asleep at that minute as the value.</li><li>Loop through each minute, see if the date range contains that minute and add 1 to the associated key in the dictionary</li></ul></li><li>Return the minute with the largest value times the guard’s ID</li></ul><h3 id=implementation>Implementation<a hidden class=anchor aria-hidden=true href=#implementation>#</a></h3><p>My function for parsing the input into a dictionary of guard ID’s and arrays of dates looks like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>parseInput</span>(<span style=color:#66d9ef>_</span> string: String) -&gt; [String: [Date]] {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> inputData = string.components(separatedBy: .newlines).sorted()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> dateFormatter = DateFormatter()
</span></span><span style=display:flex><span>    dateFormatter.dateFormat = <span style=color:#e6db74>&#34;yyyy-MM-dd HH:mm&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> currentGuard = <span style=color:#e6db74>&#34;&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> timestampDict: [String: [Date]] = [:]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0.</span>.&lt;inputData.count {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> components = inputData[i].components(separatedBy: CharacterSet(charactersIn: <span style=color:#e6db74>&#34;[]&#34;</span>))
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> components[<span style=color:#ae81ff>2</span>].hasPrefix(<span style=color:#e6db74>&#34; Guard&#34;</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> num = components[<span style=color:#ae81ff>2</span>].components(separatedBy: .whitespaces)[<span style=color:#ae81ff>2</span>]
</span></span><span style=display:flex><span>            currentGuard = num
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>guard</span> <span style=color:#66d9ef>let</span> date = dateFormatter.date(from: components[<span style=color:#ae81ff>1</span>]) <span style=color:#66d9ef>else</span> { <span style=color:#66d9ef>continue</span> }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        timestampDict[currentGuard, <span style=color:#66d9ef>default</span>: []].append(date)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> timestampDict
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>I split the input data into an array separated by newlines, and I sort it because the input was not in chronological order. At first I was worried that I would have to write some logic to get it to sort correctly, but it worked out of the box because of the format of the dates in the input string. I make a <code>dateFormatter</code> whose date format matches that of the data, a <code>currentGuard</code> variable to hold the guard I’m currently working with, and a <code>timestampDict</code> variable to hold the parsed data.</p><p>Because each guard has a line that says when they begin their shift, followed by alternating lines saying when they fell asleep and when they woke back up, and because every guard starts their shift awake and always wakes back up for every time they fall asleep, all I need is the dates following the line that says which guard started their shift. I know that the even-indexed elements of the array will all be “falling asleep” dates and all the odd-indexed elements will be “waking up” dates. This becomes relevant later.</p><p>So I split each line on the bracket characters and if the line starts with <code>"Guard"</code>, then I know it is the beginning of a new shift, so I just set <code>currentGuard</code> to that guard’s ID number and continue. For each subsequent line until I hit another that starts with “Guard” I pull out just the date and append it to the array associated with the current Guard’s ID. And at the end I return the dictionary.</p><p>My function for counting the minutes each guard was asleep looks like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>countMinutesAsleep</span>(<span style=color:#66d9ef>_</span> guardDict: [String: [Date]]) -&gt; [String: Int] {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> sleepCount: [String: Int] = [:]
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (key, value) <span style=color:#66d9ef>in</span> guardDict {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> index <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0.</span>.&lt;value.count<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> index <span style=color:#f92672>%</span> <span style=color:#ae81ff>2</span> == <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> interval = DateInterval(start: value[index], end: value[index<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>])
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> minutes = Int(interval.duration<span style=color:#f92672>/</span><span style=color:#ae81ff>60</span>)
</span></span><span style=display:flex><span>                sleepCount[key, <span style=color:#66d9ef>default</span>: <span style=color:#ae81ff>0</span>] <span style=color:#f92672>+=</span> minutes
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> sleepCount
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>I start by making a dictionary to hold the guard IDs and the number of minutes they’ve been asleep. Then I loop through all the keys and values in the dictionary. Inside of that I loop through each index in 0 up to 1 less that the value’s count. The value here being the array of dates associated with that guard. I only check the even-indexed elements, because those are the falling asleep dates. I make a DateInterval starting at the falling asleep date and ending at the waking up date. Then I get an Int of the interval property from that. The interval property value is in seconds, so I divide that by 60 to get the minute value. Finally I add that to the value for the dictionary at the current key. Once I’m out of both loops, I return the dictionary.</p><p>My function for counting the times a particular guard was a sleep at each minute looks like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>countTimesAsleepAtMinute</span>(<span style=color:#66d9ef>_</span> dates: [Date]) -&gt; [Int: Int] {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> minuteFormatter = DateFormatter()
</span></span><span style=display:flex><span>    minuteFormatter.dateFormat = <span style=color:#e6db74>&#34;mm&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> minuteDict: [Int: Int] = [:]
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> minute <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0.</span>.&lt;<span style=color:#ae81ff>60</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> index <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0.</span>.&lt;dates.count<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> index <span style=color:#f92672>%</span> <span style=color:#ae81ff>2</span> == <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>guard</span> <span style=color:#66d9ef>let</span> fallAsleep = Int(minuteFormatter.string(from: dates[index])),
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>let</span> wakeUp = Int(minuteFormatter.string(from: dates[index<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>])) <span style=color:#66d9ef>else</span> { <span style=color:#66d9ef>continue</span> }
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> minute <span style=color:#f92672>&gt;=</span> fallAsleep <span style=color:#f92672>&amp;&amp;</span> minute <span style=color:#f92672>&lt;</span> wakeUp {
</span></span><span style=display:flex><span>                    minuteDict[minute, <span style=color:#66d9ef>default</span>: <span style=color:#ae81ff>0</span>] <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> minuteDict
</span></span><span style=display:flex><span>} I
</span></span></code></pre></div><p>I make a dateFormatter that will pull out just the minute value from a date (because that is all that is relevant in the given data), and a dictionary to hold the minutes and counts. Then I loop through every value from 0 up to 60 (all of the minute values), and inside of that, loop through all of the dates in the array. Again, I only check the even-indexed items because those are the “falling asleep” dates. I use my minute formatted to get the <code>fallAsleep</code> minute and the <code>wakeUp</code> minute and if the current minute is between those two values, I add 1 to the dictionary value at the current minute’s key. This is not the most efficient way to do this, but it works and is efficient enough for the given data.</p><p>Finally, my main function to solve the problem looks like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>findSleepyGuard1</span>(<span style=color:#66d9ef>_</span> string: String) -&gt; Int {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> timestampDict = parseInput(string)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> sleepCount = countMinutesAsleep(timestampDict)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>guard</span> <span style=color:#66d9ef>let</span> biggest = sleepCount.max(by: { $0.value <span style=color:#f92672>&lt;</span> $1.value }) <span style=color:#66d9ef>else</span> { <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span> }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> sleepyGuardArray = timestampDict[biggest.key] ?? []
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> minuteDict = countTimesAsleepAtMinute(sleepyGuardArray)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>guard</span> <span style=color:#66d9ef>let</span> frequentlyAsleep = minuteDict.max(by: { $0.value <span style=color:#f92672>&lt;</span> $1.value }) <span style=color:#66d9ef>else</span> { <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span> }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> minute = frequentlyAsleep.key
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> guardId = Int(biggest.key.components(separatedBy: CharacterSet(charactersIn: <span style=color:#e6db74>&#34;#&#34;</span>)).joined()) ?? <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> minute <span style=color:#f92672>*</span> guardId
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>I get a dictionary of the times each guard is asleep from the <code>pasreInput()</code> function and a dictionary of how many minutes each guard spent asleep from the <code>countMinutesAsleep()</code> function. I pull the guard who was asleep the most out of that dictionary, and then I call <code>countTimesAsleepAtMinute()</code> with their associated dates. I pull the minute they were frequently asleep out of that dictionary and then multiply it by the guard’s ID number.</p><p>The answer for my input was <code>85296</code> and it takes about 40 milliseconds to find it using the Swift script method described in <a href=https://dillon-mce.com/posts/aoc2018/setup/>my AoC Setup post</a>.</p><h2 id=problem-2httpsadventofcodecom2018day4part2><a href=https://adventofcode.com/2018/day/4#part2>Problem 2</a><a hidden class=anchor aria-hidden=true href=#problem-2httpsadventofcodecom2018day4part2>#</a></h2><p>I would describe the second problem like this: given the same input String, return an Int which is the ID number of the guard who is asleep at the same minute the most, times the minute at which they are asleep the most. The sample data returns <code>4455</code>.</p><h3 id=method-1>Method<a hidden class=anchor aria-hidden=true href=#method-1>#</a></h3><p>This is how I solved this problem:</p><ul><li>Use the same <code>parseInput()</code> function to get a dictionary of guard IDs and arrays of dates.</li><li>Write a function that does the same thing as <code>countTimesAsleepAtMinute()</code> in the previous part, but does it for every guard and returns a dictionary of guard IDs and minute dictionaries.</li><li>Once I have that dictionary, find the guard who was asleep the most frequently at any given minute.</li><li>Return the minute times the guard’s ID</li></ul><h3 id=implementation-1>Implementation<a hidden class=anchor aria-hidden=true href=#implementation-1>#</a></h3><p>My new <code>countTimesAsleepAtMinute()</code> function looks like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>countTimesAsleepAtMinute</span>(<span style=color:#66d9ef>_</span> dates: [String: [Date]]) -&gt; [String: [Int: Int]] {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> minuteFormatter = DateFormatter()
</span></span><span style=display:flex><span>    minuteFormatter.dateFormat = <span style=color:#e6db74>&#34;mm&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> minuteDict: [String: [Int: Int]] = [:]
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (guardID, times) <span style=color:#66d9ef>in</span> dates {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>for</span> (guardID, times) <span style=color:#66d9ef>in</span> dates {
</span></span><span style=display:flex><span>      minuteDict[guardID] = countTimesAsleepAtMinute(times)
</span></span><span style=display:flex><span>      <span style=color:#960050;background-color:#1e0010>ß</span>}
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> minuteDict
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>I’ve added yet another loop outside of the others calls my old <code>countTimesAsleepAtMinute()</code> function, and it saves the resulting array into the result dictionary, using the guard’s ID as the key. This is where the efficiency of those inner loops starts to make a difference, but for the given data, the extra time it takes is still negligible.</p><p>My main function looks like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>findSleepyGuard2</span>(<span style=color:#66d9ef>_</span> string: String) -&gt; Int {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> timestampDict = parseInput(string)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> minuteDict = countTimesAsleepAtMinute(timestampDict)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> mostMinutes: (key: Int, value: Int) = (<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> consistentlySleepyGuard = <span style=color:#e6db74>&#34;&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (guardId, dict) <span style=color:#66d9ef>in</span> minuteDict {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>guard</span> <span style=color:#66d9ef>let</span> max = dict.max(by: { $0.value <span style=color:#f92672>&lt;</span> $1.value }) <span style=color:#66d9ef>else</span> { <span style=color:#66d9ef>continue</span> }
</span></span><span style=display:flex><span>        <span style=color:#75715e>//print(&#34;Guard \(guardId) was asleep at minute \(max.key) \(max.value) times&#34;)</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> max.value <span style=color:#f92672>&gt;</span> mostMinutes.value {
</span></span><span style=display:flex><span>            mostMinutes = max
</span></span><span style=display:flex><span>            consistentlySleepyGuard = guardId
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> minute = mostMinutes.key
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> guardId = Int(consistentlySleepyGuard.components(separatedBy: CharacterSet(charactersIn: <span style=color:#e6db74>&#34;#&#34;</span>)).joined()) ?? <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> minute <span style=color:#f92672>*</span> guardId
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>I get a dictionary of guard IDs and arrays of dates from the <code>parseInput()</code> function and I get a dictionary of guard IDs and dictionaries of minutes and minute counts from the <code>countTimesAsleepAtMinute()</code> function. Then I make variables to hold a tuple of the mostMinutes info and a string of the most consistently sleep guard. Then I loop through all the keys and values in the dictionary, pull the max value out of the value dictionary and if it’s value is bigger than the current <code>mostMinutes</code>, set <code>mostMinutes</code> to it and set the <code>consistentlySleepyGuard</code> to the current key. At the end, I return the guard ID number times the minute.</p><p>The answer for my input was <code>58559</code> and it takes about 0.2 seconds to find it using the script method.</p><h2 id=reflections>Reflections<a hidden class=anchor aria-hidden=true href=#reflections>#</a></h2><ul><li>This problem gave me the opportunity to practice with dictionaries and arrays, and nesting them within each other.</li><li>It also forced me to think about the computation complexity nested loops.</li></ul><p>You can find all the code for my attempts so far in <a href=https://github.com/dillon-mce/advent-of-code-2018>my advent of code 2018 repository on GitHub</a>.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://dillon-mce.com/tags/advent-of-code/>Advent of Code</a></li></ul><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Advent of Code 2018 - Day 4 on twitter" href="https://twitter.com/intent/tweet/?text=Advent%20of%20Code%202018%20-%20Day%204&url=https%3a%2f%2fdillon-mce.com%2fposts%2faoc2018%2fday4%2f&hashtags=AdventofCode"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Advent of Code 2018 - Day 4 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fdillon-mce.com%2fposts%2faoc2018%2fday4%2f&title=Advent%20of%20Code%202018%20-%20Day%204&summary=Advent%20of%20Code%202018%20-%20Day%204&source=https%3a%2f%2fdillon-mce.com%2fposts%2faoc2018%2fday4%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Advent of Code 2018 - Day 4 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fdillon-mce.com%2fposts%2faoc2018%2fday4%2f&title=Advent%20of%20Code%202018%20-%20Day%204"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></div></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><footer class=footer><span>&copy; 2022 <a href=https://dillon-mce.com>Dillon McElhinney</a></span></footer><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>