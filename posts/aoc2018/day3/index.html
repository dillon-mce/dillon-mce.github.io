<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="og:site_name" content="Dev with Dillon"/><link rel="canonical" href="https://dillon-mce.com/posts/aoc2018/day3"/><meta name="twitter:url" content="https://dillon-mce.com/posts/aoc2018/day3"/><meta name="og:url" content="https://dillon-mce.com/posts/aoc2018/day3"/><title>Advent of Code 2018 - Day 3 | Dev with Dillon</title><meta name="twitter:title" content="Advent of Code 2018 - Day 3 | Dev with Dillon"/><meta name="og:title" content="Advent of Code 2018 - Day 3 | Dev with Dillon"/><meta name="description" content="My understanding of day 3’s first problem is this: given a string that is a list of fabric claims like "#1 @ 1,3: 4x4 #2 @ 3,1: 4x4 #3 @ 5,5: 2x2" on a large grid of fabric (with the coordinates starting at the top left), return an Int which is the number square inches claimed more than once."/><meta name="twitter:description" content="My understanding of day 3’s first problem is this: given a string that is a list of fabric claims like "#1 @ 1,3: 4x4 #2 @ 3,1: 4x4 #3 @ 5,5: 2x2" on a large grid of fabric (with the coordinates starting at the top left), return an Int which is the number square inches claimed more than once."/><meta name="og:description" content="My understanding of day 3’s first problem is this: given a string that is a list of fabric claims like "#1 @ 1,3: 4x4 #2 @ 3,1: 4x4 #3 @ 5,5: 2x2" on a large grid of fabric (with the coordinates starting at the top left), return an Int which is the number square inches claimed more than once."/><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="/styles.css" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="shortcut icon" href="/images/favicon.png" type="image/png"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to Dev with Dillon"/></head><body class="item-page"><header><div class="wrapper"><div class="inner-header"><a href="/" class="logo"><img src="/images/logo.png" alt="Dillon's memoji" class="logo-image"/>Dev with Dillon</a><nav><ul><li><a href="/posts" class="selected">Blog</a></li><li><a href="/resume">CV</a></li></ul></nav></div></div></header><div class="wrapper"><article><h1>Advent of Code 2018 - Day 3</h1><p class="read-time">8 minute read</p><div class="content"><h2><a href="https://adventofcode.com/2018/day/3">Problem 1</a></h2><p>My understanding of day 3’s first problem is this: given a string that is a list of fabric claims like <code>"#1 @ 1,3: 4x4\n#2 @ 3,1: 4x4\n#3 @ 5,5: 2x2"</code> on a large grid of fabric (with the coordinates starting at the top left), return an Int which is the number square inches claimed more than once. The sample data returns <code>4</code>.</p><h3>Method</h3><p>To solve this problem I needed: - To define a Point struct to deal with coordinates - Define a Claim struct that has an id, a size (x, y, h, w)	- It also needs a computed property that is a set of the points it contains	- A method that returns the points that intersect with another claim	- A method to check if there is any overlap between claims. At first I thought I would only need the first two, but I found that it was too calculation time intensive, so I added a faster function that just does a little math to see if they overlap, and only getting all their points and finding the intersection if we know they overlap. - A helper method to parse the input into an array of Claims - The main function which will have a set of points, loop through all the claims, check them for overlapping area with all the other claims, and if it finds any, get their intersecting points and add them to the set.</p><h3>Implementation</h3><p>My Point struct is pretty straightforward, it looks like this:</p><pre><code><span class="keyword">struct</span> Point: <span class="type">Hashable</span>, <span class="type">CustomStringConvertible</span> {
    <span class="keyword">let</span> x: <span class="type">Int</span>
    <span class="keyword">let</span> y: <span class="type">Int</span>

    <span class="keyword">var</span> description: <span class="type">String</span> {
        <span class="keyword">return</span> <span class="string">"Point(x:</span> \(x)<span class="string">, y:</span> \(y)<span class="string">)"</span>
    }

}
</code></pre><p>It is hashable, so that I can make a set of Points, and I added a custom description, to make things a little easier to read when I printed stuff out.</p><p>The Claim struct looks like this:</p><pre><code><span class="keyword">struct</span> Claim: <span class="type">Hashable</span> {
    <span class="keyword">let</span> id: <span class="type">String</span>
    <span class="keyword">let</span> x: <span class="type">Int</span>
    <span class="keyword">let</span> y: <span class="type">Int</span>
    <span class="keyword">let</span> height: <span class="type">Int</span>
    <span class="keyword">let</span> width: <span class="type">Int</span>

    <span class="keyword">var</span> internalPoints: <span class="type">Set</span>&lt;<span class="type">Point</span>&gt; {
        <span class="keyword">var</span> set: <span class="type">Set</span>&lt;<span class="type">Point</span>&gt; = <span class="type">Set</span>()
        <span class="keyword">for</span> x <span class="keyword">in</span> x..&lt;(x + width) {
            <span class="keyword">for</span> y <span class="keyword">in</span> y..&lt;(y + height) {
                <span class="keyword">let</span> point = <span class="type">Point</span>(x: x, y: y)
                set.<span class="call">insert</span>(point)
            }
        }
        <span class="keyword">return set</span>
    }
}
</code></pre><p>I probably could have defined it to use a point instead of an x and y, and maybe also defined the height and width off of a second point, but as I was thinking through this problem, I started with the Claim struct and by the time I had a Point, I didn’t want to go back and rewrite the code I had. It may make some of the math easier though. Probably worth looking into at some point. Other than that, the only interesting thing here is the internal point property, which calculates a set of all the internal points each time it is called. This cuts down on memory usage, but increases calculation time, which is why I try to only call it it when I have to.</p><p>The function that returns a set of intersecting points looks like this:</p><pre><code><span class="keyword">func</span> getIntersectionPoints(with claim: <span class="type">Claim</span>) -&gt; <span class="type">Set</span>&lt;<span class="type">Point</span>&gt; {
    <span class="keyword">return self</span>.<span class="property">internalPoints</span>.<span class="call">intersection</span>(claim.<span class="property">internalPoints</span>)
}
</code></pre><p>It just finds and returns the intersection of the claim it is called on’s internal points and the claim it is called with’s internal points.</p><p>The function which calculates the overlapping area looks like this:</p><pre><code><span class="keyword">func</span> overlappingArea(with claim: <span class="type">Claim</span>) -&gt; <span class="type">Int</span> {
    <span class="keyword">let</span> overlapX = <span class="call">min</span>((<span class="keyword">self</span>.<span class="property">x</span> + <span class="keyword">self</span>.<span class="property">width</span>), (claim.<span class="property">x</span> + claim.<span class="property">width</span>)) - <span class="call">max</span>(<span class="keyword">self</span>.<span class="property">x</span>, claim.<span class="property">x</span>)
    <span class="keyword">let</span> overlapY = <span class="call">min</span>((<span class="keyword">self</span>.<span class="property">y</span> + <span class="keyword">self</span>.<span class="property">height</span>), (claim.<span class="property">y</span> + claim.<span class="property">height</span>)) - <span class="call">max</span>(<span class="keyword">self</span>.<span class="property">y</span>, claim.<span class="property">y</span>)

    <span class="keyword">guard</span> overlapX &gt; <span class="number">0</span>, overlapY &gt; <span class="number">0</span> <span class="keyword">else</span> { <span class="keyword">return</span> <span class="number">0</span> }

    <span class="keyword">return</span> overlapX * overlapY

}
</code></pre><p>I got the math from this <a href="https://www.geeksforgeeks.org/total-area-two-overlapping-rectangles/">Geeks for Geeks article</a> and modified it a little to fit the need here (the math in the article assumes there is some overlap). Basically you get the whichever right side of the rectangle is smaller and subtract whichever left side is bigger and if the result is positive, they over lap on the x-axis. You do the same for the y-axis and if they are both positive, it means there is some overlap. I return an Int in case at some point I need to know how much they overlap, but I could just have easily returned a Bool because all I really need to know is if they overlap or not.</p><p>My function to parse the claim looks like this:</p><pre><code><span class="keyword">func</span> parseInput(<span class="keyword">_</span> string: <span class="type">String</span>) -&gt; [<span class="type">Claim</span>] {
    <span class="keyword">let</span> array = string.<span class="call">components</span>(separatedBy: .<span class="dotAccess">newlines</span>)
    <span class="keyword">var</span> results: [<span class="type">Claim</span>] = []

    <span class="keyword">for</span> (index, item) <span class="keyword">in</span> array.<span class="call">enumerated</span>() {
        <span class="keyword">let</span> secondArray = item.<span class="call">components</span>(separatedBy: .<span class="dotAccess">whitespaces</span>)
        <span class="keyword">let</span> id = secondArray[<span class="number">0</span>]
        <span class="keyword">let</span> originArray = secondArray[<span class="number">2</span>].<span class="call">components</span>(separatedBy: .<span class="dotAccess">punctuationCharacters</span>)
        <span class="keyword">let</span> boundsArray = secondArray[<span class="number">3</span>].<span class="call">components</span>(separatedBy: .<span class="dotAccess">lowercaseLetters</span>)
        <span class="keyword">guard let</span> x = <span class="type">Int</span>(originArray[<span class="number">0</span>]),
            <span class="keyword">let</span> y = <span class="type">Int</span>(originArray[<span class="number">1</span>]),
            <span class="keyword">let</span> width = <span class="type">Int</span>(boundsArray[<span class="number">0</span>]),
            <span class="keyword">let</span> height = <span class="type">Int</span>(boundsArray[<span class="number">1</span>]) <span class="keyword">else</span> {
                <span class="call">print</span>(<span class="string">"Couldn't convert something correctly. Check loop</span> \(index + <span class="number">1</span>)<span class="string">"</span>)
                <span class="call">print</span>(<span class="string">"Array:</span> \(secondArray)<span class="string">"</span>)
                <span class="keyword">continue</span>
        }
        <span class="keyword">let</span> claim = <span class="type">Claim</span>(id: id, x: x, y: y, height: height, width: width)
        results.<span class="call">append</span>(claim)
    }

    <span class="keyword">return</span> results
}
</code></pre><p>It is a little bit of a mess. I start by splitting the input string into an array by newlines and giving myself an array to hold the claims that are made. Then I loop through the array to make a Claim out of each line. I used <code>.enumerated()</code> so I could grab the index for my print out if something failed.</p><p>To make a Claim, I split each line by whitespaces. The id is the first element of that array. The origin point is the third element in the array, which I split on punctuation. The height and width are the fourth element, which I split on lowercase letters, because it is an <code>"x"</code> in the input. I then pull out the individual elements, turn them into Ints and store them in variables. It that is successful, I make a claim from the pieces and append it to the array.</p><p>Finally, my main function looks like this:</p><pre><code><span class="keyword">func</span> addOverlappingArea(<span class="keyword">_</span> string: <span class="type">String</span>) -&gt; <span class="type">Int</span> {
    <span class="keyword">let</span> claims = <span class="call">parseInput</span>(string)
    <span class="keyword">var</span> points: <span class="type">Set</span>&lt;<span class="type">Point</span>&gt; = <span class="type">Set</span>()
    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;claims.<span class="property">count</span>-<span class="number">1</span> {
        <span class="keyword">for</span> j <span class="keyword">in</span> i+<span class="number">1</span>..&lt;claims.<span class="property">count</span> {
            <span class="keyword">let</span> claim1 = claims[i]
            <span class="keyword">let</span> claim2 = claims[j]
            <span class="keyword">if</span> claim1.<span class="call">overlappingArea</span>(with: claim2) &gt; <span class="number">0</span> {
                points.<span class="call">formUnion</span>(claim1.<span class="call">getIntersectionPoints</span>(with: claim2))
            }
        }
    }
    <span class="keyword">return</span> points.<span class="property">count</span>
}
</code></pre><p>I get an array of claims from my <code>parseInput()</code> function and make an empty array of points to hold the overlapping points. Then I loop through the claims and check each one against all the others to see if they overlap, and if they do I get a set of of the intersecting points and add that to my points set.</p><p>The answer for my input was 111326 and it takes about 0.6 seconds to find the answer using the swift script method described in <a href="{{"/Advent-of-Code-2018-Setup" | absolute_url}}">my AoC setup post</a>.</p><h2><a href="https://adventofcode.com/2018/day/3#part2">Problem 2</a></h2><p>Part two was much simpler, now that I had all the infrastructure built out. The problem is basically: given a string of claims, return the ID of the single claim that doesn’t overlap with any others. The sample data returns <code>#3</code>.</p><h3>Method</h3><ul><li>Use the same <code>parseInput()</code> method to get an array of claims.</li><li>Make a set of Claims to hold the claims with no overlaps.</li><li>Loop through all the claims, checking them against all the others and if they have any overlap, remove both from the set.</li><li>At the end, if there is an element left, return it.</li></ul><h3>Implementation</h3><p>The only new code for this part was the main function:</p><pre><code><span class="keyword">func</span> findNoOverlaps(<span class="keyword">_</span> string: <span class="type">String</span>) -&gt; <span class="type">Claim</span>? {
    <span class="keyword">let</span> claims = <span class="call">parseInput</span>(string)
    <span class="keyword">var</span> noOverlaps: <span class="type">Set</span>&lt;<span class="type">Claim</span>&gt; = <span class="type">Set</span>(claims)
    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;claims.<span class="property">count</span> {
        <span class="keyword">for</span> j <span class="keyword">in</span> i+<span class="number">1</span>..&lt;claims.<span class="property">count</span> {
            <span class="keyword">let</span> claim1 = claims[i]
            <span class="keyword">let</span> claim2 = claims[j]
            <span class="keyword">if</span> claim1.<span class="call">overlappingArea</span>(with: claim2) &gt; <span class="number">0</span> {
                noOverlaps.<span class="call">remove</span>(claim1)
                noOverlaps.<span class="call">remove</span>(claim2)
            }
        }
    }
    <span class="keyword">return</span> noOverlaps.<span class="property">count</span> == <span class="number">1</span> ? noOverlaps.<span class="call">removeFirst</span>() : <span class="keyword">nil</span>
}
</code></pre><p>I get my claims from the <code>parseInput()</code> function, and make a set equal from that array of claims. Then I loop through each claim, checking it against all the other claims for an overlap. If there is any, I remove both from the set. This will loop through all of the claims, even if they have already been removed from the set, but I didn’t want to take the time to write it in a more efficient way because it already takes a negligible amount of time for the given input.</p><p>The answer for my input was claim #1019 and it takes about 0.2 seconds to find it running the script on the command line.</p><h2>Reflections</h2><ul><li>This problem really stretched my memory of high school geometry class, and forced me to think about how to deal with a coordinate system in code.</li><li>It also gave me the opportunity to explore the capabilities of Sets a little more, as well as making custom structs that are Hashable.</li></ul><p>You can find all the code for my attempts so far in <a href="https://github.com/dillon-mce/advent-of-code-2018">my advent of code 2018 repository on GitHub</a>.</p></div><span>Tagged with: </span><ul class="tag-list"><li><a href="/tags/adventofcode">adventofcode</a></li></ul></article></div><footer><p>© 2022 Dillon McElhinney. Generated with <a href="https://github.com/johnsundell/publish">Publish</a> ⚡️ fueled by <a href="https://www.buymeacoffee.com/dilloncodes">coffee</a> ☕️</p></footer></body></html>