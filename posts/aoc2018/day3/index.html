<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Advent of Code 2018 - Day 3 | Develop with Dillon</title><meta name=keywords content="Advent of Code"><meta name=description content="Problem 1 My understanding of day 3’s first problem is this: given a string that is a list of fabric claims like &#34;#1 @ 1,3: 4x4\n#2 @ 3,1: 4x4\n#3 @ 5,5: 2x2&#34; on a large grid of fabric (with the coordinates starting at the top left), return an Int which is the number square inches claimed more than once. The sample data returns 4.
Method To solve this problem I needed:"><meta name=author content><link rel=canonical href=https://dillon-mce.com/posts/aoc2018/day3/><link crossorigin=anonymous href=/assets/css/stylesheet.min.ae9017796fc0b71882930de374a7047229b17dd0004f5e7d194bd3dc1413bee5.css integrity="sha256-rpAXeW/AtxiCkw3jdKcEcimxfdAAT159GUvT3BQTvuU=" rel="preload stylesheet" as=style><link rel=icon href=https://dillon-mce.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://dillon-mce.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://dillon-mce.com/favicon-32x32.png><link rel=apple-touch-icon href=https://dillon-mce.com/apple-touch-icon.png><link rel=mask-icon href=https://dillon-mce.com/favicon-32x32.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-YZRJY88933"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-YZRJY88933")</script><meta property="og:title" content="Advent of Code 2018 - Day 3"><meta property="og:description" content="Problem 1 My understanding of day 3’s first problem is this: given a string that is a list of fabric claims like &#34;#1 @ 1,3: 4x4\n#2 @ 3,1: 4x4\n#3 @ 5,5: 2x2&#34; on a large grid of fabric (with the coordinates starting at the top left), return an Int which is the number square inches claimed more than once. The sample data returns 4.
Method To solve this problem I needed:"><meta property="og:type" content="article"><meta property="og:url" content="https://dillon-mce.com/posts/aoc2018/day3/"><meta property="og:image" content="https://dillon-mce.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-12-04T00:00:00+00:00"><meta property="article:modified_time" content="2018-12-04T00:00:00+00:00"><meta property="og:site_name" content="Develop with Dillon"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://dillon-mce.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Advent of Code 2018 - Day 3"><meta name=twitter:description content="Problem 1 My understanding of day 3’s first problem is this: given a string that is a list of fabric claims like &#34;#1 @ 1,3: 4x4\n#2 @ 3,1: 4x4\n#3 @ 5,5: 2x2&#34; on a large grid of fabric (with the coordinates starting at the top left), return an Int which is the number square inches claimed more than once. The sample data returns 4.
Method To solve this problem I needed:"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://dillon-mce.com/posts/"},{"@type":"ListItem","position":3,"name":"Advent of Code 2018 - Day 3","item":"https://dillon-mce.com/posts/aoc2018/day3/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Advent of Code 2018 - Day 3","name":"Advent of Code 2018 - Day 3","description":"Problem 1 My understanding of day 3’s first problem is this: given a string that is a list of fabric claims like \u0026quot;#1 @ 1,3: 4x4\\n#2 @ 3,1: 4x4\\n#3 @ 5,5: 2x2\u0026quot; on a large grid of fabric (with the coordinates starting at the top left), return an Int which is the number square inches claimed more than once. The sample data returns 4.\nMethod To solve this problem I needed:","keywords":["Advent of Code"],"articleBody":"Problem 1 My understanding of day 3’s first problem is this: given a string that is a list of fabric claims like \"#1 @ 1,3: 4x4\\n#2 @ 3,1: 4x4\\n#3 @ 5,5: 2x2\" on a large grid of fabric (with the coordinates starting at the top left), return an Int which is the number square inches claimed more than once. The sample data returns 4.\nMethod To solve this problem I needed:\nTo define a Point struct to deal with coordinates Define a Claim struct that has an id, a size (x, y, h, w) It also needs a computed property that is a set of the points it contains A method that returns the points that intersect with another claim A method to check if there is any overlap between claims. At first I thought I would only need the first two, but I found that it was too calculation time intensive, so I added a faster function that just does a little math to see if they overlap, and only getting all their points and finding the intersection if we know they overlap. A helper method to parse the input into an array of Claims The main function which will have a set of points, loop through all the claims, check them for overlapping area with all the other claims, and if it finds any, get their intersecting points and add them to the set. Implementation My Point struct is pretty straightforward, it looks like this:\nstruct Point: Hashable, CustomStringConvertible { let x: Int let y: Int var description: String { return \"Point(x: \\(x), y: \\(y))\" } } It is hashable, so that I can make a set of Points, and I added a custom description, to make things a little easier to read when I printed stuff out.\nThe Claim struct looks like this:\nstruct Claim: Hashable { let id: String let x: Int let y: Int let height: Int let width: Int var internalPoints: Set { var set: Set = Set() for x in x..\u003c(x + width) { for y in y..\u003c(y + height) { let point = Point(x: x, y: y) set.insert(point) } } return set } } I probably could have defined it to use a point instead of an x and y, and maybe also defined the height and width off of a second point, but as I was thinking through this problem, I started with the Claim struct and by the time I had a Point, I didn’t want to go back and rewrite the code I had. It may make some of the math easier though. Probably worth looking into at some point. Other than that, the only interesting thing here is the internal point property, which calculates a set of all the internal points each time it is called. This cuts down on memory usage, but increases calculation time, which is why I try to only call it it when I have to.\nThe function that returns a set of intersecting points looks like this:\nfunc getIntersectionPoints(with claim: Claim) -\u003e Set { return self.internalPoints.intersection(claim.internalPoints) } It just finds and returns the intersection of the claim it is called on’s internal points and the claim it is called with’s internal points.\nThe function which calculates the overlapping area looks like this:\nfunc overlappingArea(with claim: Claim) -\u003e Int { let overlapX = min((self.x + self.width), (claim.x + claim.width)) - max(self.x, claim.x) let overlapY = min((self.y + self.height), (claim.y + claim.height)) - max(self.y, claim.y) guard overlapX \u003e 0, overlapY \u003e 0 else { return 0 } return overlapX * overlapY } I got the math from this Geeks for Geeks article and modified it a little to fit the need here (the math in the article assumes there is some overlap). Basically you get the whichever right side of the rectangle is smaller and subtract whichever left side is bigger and if the result is positive, they over lap on the x-axis. You do the same for the y-axis and if they are both positive, it means there is some overlap. I return an Int in case at some point I need to know how much they overlap, but I could just have easily returned a Bool because all I really need to know is if they overlap or not.\nMy function to parse the claim looks like this:\nfunc parseInput(_ string: String) -\u003e [Claim] { let array = string.components(separatedBy: .newlines) var results: [Claim] = [] for (index, item) in array.enumerated() { let secondArray = item.components(separatedBy: .whitespaces) let id = secondArray[0] let originArray = secondArray[2].components(separatedBy: .punctuationCharacters) let boundsArray = secondArray[3].components(separatedBy: .lowercaseLetters) guard let x = Int(originArray[0]), let y = Int(originArray[1]), let width = Int(boundsArray[0]), let height = Int(boundsArray[1]) else { print(\"Couldn't convert something correctly. Check loop \\(index + 1)\") print(\"Array: \\(secondArray)\") continue } let claim = Claim(id: id, x: x, y: y, height: height, width: width) results.append(claim) } return results } It is a little bit of a mess. I start by splitting the input string into an array by newlines and giving myself an array to hold the claims that are made. Then I loop through the array to make a Claim out of each line. I used .enumerated() so I could grab the index for my print out if something failed.\nTo make a Claim, I split each line by whitespaces. The id is the first element of that array. The origin point is the third element in the array, which I split on punctuation. The height and width are the fourth element, which I split on lowercase letters, because it is an \"x\" in the input. I then pull out the individual elements, turn them into Ints and store them in variables. It that is successful, I make a claim from the pieces and append it to the array.\nFinally, my main function looks like this:\nfunc addOverlappingArea(_ string: String) -\u003e Int { let claims = parseInput(string) var points: Set = Set() for i in 0..","wordCount":"1464","inLanguage":"en","datePublished":"2018-12-04T00:00:00Z","dateModified":"2018-12-04T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://dillon-mce.com/posts/aoc2018/day3/"},"publisher":{"@type":"Organization","name":"Develop with Dillon","logo":{"@type":"ImageObject","url":"https://dillon-mce.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://dillon-mce.com accesskey=h title="Devlop with Dillon (Alt + H)"><img src=https://dillon-mce.com/apple-touch-icon.png alt=logo aria-label=logo height=35>Devlop with Dillon</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://dillon-mce.com/ title=Home><span>Home</span></a></li><li><a href=https://dillon-mce.com/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://dillon-mce.com/cv title=CV><span>CV</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Advent of Code 2018 - Day 3</h1><div class=post-meta><span title='2018-12-04 00:00:00 +0000 UTC'>December 4, 2018</span>&nbsp;·&nbsp;7 min&nbsp;|&nbsp;<a class=muted href=https://github.com/dillon-mce/dillon-mce.github.io/blob/main/content/posts/2018-12-04-Advent-of-Code-2018-Day-3.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><h2 id=problem-1httpsadventofcodecom2018day3><a href=https://adventofcode.com/2018/day/3>Problem 1</a><a hidden class=anchor aria-hidden=true href=#problem-1httpsadventofcodecom2018day3>#</a></h2><p>My understanding of day 3’s first problem is this: given a string that is a list of fabric claims like <code>"#1 @ 1,3: 4x4\n#2 @ 3,1: 4x4\n#3 @ 5,5: 2x2"</code> on a large grid of fabric (with the coordinates starting at the top left), return an Int which is the number square inches claimed more than once. The sample data returns <code>4</code>.</p><h3 id=method>Method<a hidden class=anchor aria-hidden=true href=#method>#</a></h3><p>To solve this problem I needed:</p><ul><li>To define a Point struct to deal with coordinates</li><li>Define a Claim struct that has an id, a size (x, y, h, w)<ul><li>It also needs a computed property that is a set of the points it contains</li><li>A method that returns the points that intersect with another claim</li><li>A method to check if there is any overlap between claims. At first I thought I would only need the first two, but I found that it was too calculation time intensive, so I added a faster function that just does a little math to see if they overlap, and only getting all their points and finding the intersection if we know they overlap.</li></ul></li><li>A helper method to parse the input into an array of Claims</li><li>The main function which will have a set of points, loop through all the claims, check them for overlapping area with all the other claims, and if it finds any, get their intersecting points and add them to the set.</li></ul><h3 id=implementation>Implementation<a hidden class=anchor aria-hidden=true href=#implementation>#</a></h3><p>My Point struct is pretty straightforward, it looks like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Point</span>: Hashable, CustomStringConvertible {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> x: Int
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> y: Int
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> description: String {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;Point(x: </span><span style=color:#e6db74>\(</span>x<span style=color:#e6db74>)</span><span style=color:#e6db74>, y: </span><span style=color:#e6db74>\(</span>y<span style=color:#e6db74>)</span><span style=color:#e6db74>)&#34;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>It is hashable, so that I can make a set of Points, and I added a custom description, to make things a little easier to read when I printed stuff out.</p><p>The Claim struct looks like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Claim</span>: Hashable {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> id: String
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> x: Int
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> y: Int
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> height: Int
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> width: Int
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> internalPoints: Set&lt;Point&gt; {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> set: Set&lt;Point&gt; = Set()
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> x <span style=color:#66d9ef>in</span> x..<span style=color:#f92672>&lt;</span>(x <span style=color:#f92672>+</span> width) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> y <span style=color:#66d9ef>in</span> y..<span style=color:#f92672>&lt;</span>(y <span style=color:#f92672>+</span> height) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> point = Point(x: x, y: y)
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>set</span>.insert(point)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>set</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>I probably could have defined it to use a point instead of an x and y, and maybe also defined the height and width off of a second point, but as I was thinking through this problem, I started with the Claim struct and by the time I had a Point, I didn’t want to go back and rewrite the code I had. It may make some of the math easier though. Probably worth looking into at some point. Other than that, the only interesting thing here is the internal point property, which calculates a set of all the internal points each time it is called. This cuts down on memory usage, but increases calculation time, which is why I try to only call it it when I have to.</p><p>The function that returns a set of intersecting points looks like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>getIntersectionPoints</span>(with claim: Claim) -&gt; Set&lt;Point&gt; {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>self</span>.internalPoints.intersection(claim.internalPoints)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>It just finds and returns the intersection of the claim it is called on’s internal points and the claim it is called with’s internal points.</p><p>The function which calculates the overlapping area looks like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>overlappingArea</span>(with claim: Claim) -&gt; Int {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> overlapX = min((<span style=color:#66d9ef>self</span>.x <span style=color:#f92672>+</span> <span style=color:#66d9ef>self</span>.width), (claim.x <span style=color:#f92672>+</span> claim.width)) <span style=color:#f92672>-</span> max(<span style=color:#66d9ef>self</span>.x, claim.x)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> overlapY = min((<span style=color:#66d9ef>self</span>.y <span style=color:#f92672>+</span> <span style=color:#66d9ef>self</span>.height), (claim.y <span style=color:#f92672>+</span> claim.height)) <span style=color:#f92672>-</span> max(<span style=color:#66d9ef>self</span>.y, claim.y)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>guard</span> overlapX <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>, overlapY <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span> <span style=color:#66d9ef>else</span> { <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span> }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> overlapX <span style=color:#f92672>*</span> overlapY
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>I got the math from this <a href=https://www.geeksforgeeks.org/total-area-two-overlapping-rectangles/>Geeks for Geeks article</a> and modified it a little to fit the need here (the math in the article assumes there is some overlap). Basically you get the whichever right side of the rectangle is smaller and subtract whichever left side is bigger and if the result is positive, they over lap on the x-axis. You do the same for the y-axis and if they are both positive, it means there is some overlap. I return an Int in case at some point I need to know how much they overlap, but I could just have easily returned a Bool because all I really need to know is if they overlap or not.</p><p>My function to parse the claim looks like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>parseInput</span>(<span style=color:#66d9ef>_</span> string: String) -&gt; [Claim] {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> array = string.components(separatedBy: .newlines)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> results: [Claim] = []
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (index, item) <span style=color:#66d9ef>in</span> array.enumerated() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> secondArray = item.components(separatedBy: .whitespaces)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> id = secondArray[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> originArray = secondArray[<span style=color:#ae81ff>2</span>].components(separatedBy: .punctuationCharacters)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> boundsArray = secondArray[<span style=color:#ae81ff>3</span>].components(separatedBy: .lowercaseLetters)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>guard</span> <span style=color:#66d9ef>let</span> x = Int(originArray[<span style=color:#ae81ff>0</span>]),
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> y = Int(originArray[<span style=color:#ae81ff>1</span>]),
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> width = Int(boundsArray[<span style=color:#ae81ff>0</span>]),
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> height = Int(boundsArray[<span style=color:#ae81ff>1</span>]) <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                print(<span style=color:#e6db74>&#34;Couldn&#39;t convert something correctly. Check loop </span><span style=color:#e6db74>\(</span>index <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span><span style=color:#e6db74>)</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>                print(<span style=color:#e6db74>&#34;Array: </span><span style=color:#e6db74>\(</span>secondArray<span style=color:#e6db74>)</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> claim = Claim(id: id, x: x, y: y, height: height, width: width)
</span></span><span style=display:flex><span>        results.append(claim)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> results
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>It is a little bit of a mess. I start by splitting the input string into an array by newlines and giving myself an array to hold the claims that are made. Then I loop through the array to make a Claim out of each line. I used <code>.enumerated()</code> so I could grab the index for my print out if something failed.</p><p>To make a Claim, I split each line by whitespaces. The id is the first element of that array. The origin point is the third element in the array, which I split on punctuation. The height and width are the fourth element, which I split on lowercase letters, because it is an <code>"x"</code> in the input. I then pull out the individual elements, turn them into Ints and store them in variables. It that is successful, I make a claim from the pieces and append it to the array.</p><p>Finally, my main function looks like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>addOverlappingArea</span>(<span style=color:#66d9ef>_</span> string: String) -&gt; Int {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> claims = parseInput(string)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> points: Set&lt;Point&gt; = Set()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0.</span>.&lt;claims.count<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> j <span style=color:#66d9ef>in</span> i<span style=color:#f92672>+</span><span style=color:#ae81ff>1.</span>.&lt;claims.count {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> claim1 = claims[i]
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> claim2 = claims[j]
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> claim1.overlappingArea(with: claim2) <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>                points.formUnion(claim1.getIntersectionPoints(with: claim2))
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> points.count
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>I get an array of claims from my <code>parseInput()</code> function and make an empty array of points to hold the overlapping points. Then I loop through the claims and check each one against all the others to see if they overlap, and if they do I get a set of of the intersecting points and add that to my points set.</p><p>The answer for my input was 111326 and it takes about 0.6 seconds to find the answer using the swift script method described in <a href=https://dillon-mce.com/posts/aoc2018/setup/>my AoC setup post</a>.</p><h2 id=problem-2httpsadventofcodecom2018day3part2><a href=https://adventofcode.com/2018/day/3#part2>Problem 2</a><a hidden class=anchor aria-hidden=true href=#problem-2httpsadventofcodecom2018day3part2>#</a></h2><p>Part two was much simpler, now that I had all the infrastructure built out. The problem is basically: given a string of claims, return the ID of the single claim that doesn’t overlap with any others. The sample data returns <code>#3</code>.</p><h3 id=method-1>Method<a hidden class=anchor aria-hidden=true href=#method-1>#</a></h3><ul><li>Use the same <code>parseInput()</code> method to get an array of claims.</li><li>Make a set of Claims to hold the claims with no overlaps.</li><li>Loop through all the claims, checking them against all the others and if they have any overlap, remove both from the set.</li><li>At the end, if there is an element left, return it.</li></ul><h3 id=implementation-1>Implementation<a hidden class=anchor aria-hidden=true href=#implementation-1>#</a></h3><p>The only new code for this part was the main function:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>findNoOverlaps</span>(<span style=color:#66d9ef>_</span> string: String) -&gt; Claim? {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> claims = parseInput(string)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> noOverlaps: Set&lt;Claim&gt; = Set(claims)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0.</span>.&lt;claims.count {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> j <span style=color:#66d9ef>in</span> i<span style=color:#f92672>+</span><span style=color:#ae81ff>1.</span>.&lt;claims.count {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> claim1 = claims[i]
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> claim2 = claims[j]
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> claim1.overlappingArea(with: claim2) <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>                noOverlaps.remove(claim1)
</span></span><span style=display:flex><span>                noOverlaps.remove(claim2)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> noOverlaps.count == <span style=color:#ae81ff>1</span> ? noOverlaps.removeFirst() : <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>I get my claims from the <code>parseInput()</code> function, and make a set equal from that array of claims. Then I loop through each claim, checking it against all the other claims for an overlap. If there is any, I remove both from the set. This will loop through all of the claims, even if they have already been removed from the set, but I didn’t want to take the time to write it in a more efficient way because it already takes a negligible amount of time for the given input.</p><p>The answer for my input was claim #1019 and it takes about 0.2 seconds to find it running the script on the command line.</p><h2 id=reflections>Reflections<a hidden class=anchor aria-hidden=true href=#reflections>#</a></h2><ul><li>This problem really stretched my memory of high school geometry class, and forced me to think about how to deal with a coordinate system in code.</li><li>It also gave me the opportunity to explore the capabilities of Sets a little more, as well as making custom structs that are Hashable.</li></ul><p>You can find all the code for my attempts so far in <a href=https://github.com/dillon-mce/advent-of-code-2018>my advent of code 2018 repository on GitHub</a>.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://dillon-mce.com/tags/advent-of-code/>Advent of Code</a></li></ul><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Advent of Code 2018 - Day 3 on twitter" href="https://twitter.com/intent/tweet/?text=Advent%20of%20Code%202018%20-%20Day%203&amp;url=https%3a%2f%2fdillon-mce.com%2fposts%2faoc2018%2fday3%2f&amp;hashtags=AdventofCode"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Advent of Code 2018 - Day 3 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fdillon-mce.com%2fposts%2faoc2018%2fday3%2f&amp;title=Advent%20of%20Code%202018%20-%20Day%203&amp;summary=Advent%20of%20Code%202018%20-%20Day%203&amp;source=https%3a%2f%2fdillon-mce.com%2fposts%2faoc2018%2fday3%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Advent of Code 2018 - Day 3 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fdillon-mce.com%2fposts%2faoc2018%2fday3%2f&title=Advent%20of%20Code%202018%20-%20Day%203"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></div></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><footer class=footer><span>&copy; 2023 <a href=https://dillon-mce.com>Dillon McElhinney</a></span></footer><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>