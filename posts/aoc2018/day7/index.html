<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Advent of Code 2018 - Day 7 | Develop with Dillon</title><meta name=keywords content="Advent of Code"><meta name=description content="My understanding of Day 7’s first problem is given a  series of instructions like the one below, return a String which is the correct order in which the instructions will be executed."><meta name=author content><link rel=canonical href=https://dillon-mce.com/posts/aoc2018/day7/><link crossorigin=anonymous href=/assets/css/stylesheet.min.ae9017796fc0b71882930de374a7047229b17dd0004f5e7d194bd3dc1413bee5.css integrity="sha256-rpAXeW/AtxiCkw3jdKcEcimxfdAAT159GUvT3BQTvuU=" rel="preload stylesheet" as=style><link rel=icon href=https://dillon-mce.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://dillon-mce.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://dillon-mce.com/favicon-32x32.png><link rel=apple-touch-icon href=https://dillon-mce.com/apple-touch-icon.png><link rel=mask-icon href=https://dillon-mce.com/favicon-32x32.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-YZRJY88933"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-YZRJY88933")</script><meta property="og:title" content="Advent of Code 2018 - Day 7"><meta property="og:description" content="My understanding of Day 7’s first problem is given a  series of instructions like the one below, return a String which is the correct order in which the instructions will be executed."><meta property="og:type" content="article"><meta property="og:url" content="https://dillon-mce.com/posts/aoc2018/day7/"><meta property="og:image" content="https://dillon-mce.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-12-08T00:00:00+00:00"><meta property="article:modified_time" content="2018-12-08T00:00:00+00:00"><meta property="og:site_name" content="Develop with Dillon"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://dillon-mce.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Advent of Code 2018 - Day 7"><meta name=twitter:description content="My understanding of Day 7’s first problem is given a  series of instructions like the one below, return a String which is the correct order in which the instructions will be executed."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://dillon-mce.com/posts/"},{"@type":"ListItem","position":3,"name":"Advent of Code 2018 - Day 7","item":"https://dillon-mce.com/posts/aoc2018/day7/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Advent of Code 2018 - Day 7","name":"Advent of Code 2018 - Day 7","description":"My understanding of Day 7’s first problem is given a  series of instructions like the one below, return a String which is the correct order in which the instructions will be executed.","keywords":["Advent of Code"],"articleBody":"Problem 1 My understanding of Day 7’s first problem is this: given a series of instructions like the one below, return a String which is the correct order in which the instructions will be executed. The sample data returns \"CABDFE\".\nStep C must be finished before step A can begin. Step C must be finished before step F can begin. Step A must be finished before step B can begin. Step A must be finished before step D can begin. Step B must be finished before step E can begin. Step D must be finished before step E can begin. Step F must be finished before step E can begin. Method My method for solving this problem looks like this:\nParse the input into a dictionary which holds steps that are dependent on others as the key and an array of the steps they are dependent as the value, and an array of all the steps that need to be executed, sorted alphabetically. Make a set to hold the steps which are completed, and an array to hold the order all the steps in the order they are completed. Using a similar method to the collapsing polymer problem, loop through a while loop until the letter array is empty. Inside of that outer loop, loop through the array until a step that can be executed is found. Execute that step. Insert it into the set of completed steps, append it to the results array, and remove it from the letter array. After the while loop, return the results array joined into a string. Implementation My parseInput() function looks like this:\nfunc parseInput(_ string: String) -\u003e ([String: [String]], [String]) { let array = string.components(separatedBy: .newlines)) var dependencyDict: [String: [String]] = [:] var letterSet: Set = Set() for line in array { let letters = line.components(separatedBy: .whitespaces).filter() { $0.count == 1 } dependencyDict[letters[1], default: []].append(letters[0]) letterSet.insert(letters[0]) letterSet.insert(letters[1]) } let letterArray = Array(letterSet).sorted() return (dependencyDict, letterArray) } First, I break the string into an array split on newlines. Then I set up a dictionary to hold the steps that are dependent and an array of the steps they are dependent on and a set to hold all of the steps that need to be executed. Then I loop through each line in the array, break it up by splitting on whitespaces and filtering for single character elements. I add the dependency to the dependency dict and make sure both letters are in the letter set. At the end I make an array from the letter set, sort it, and then return a tuple of the dependency dictionary and a letter array.\nMy main function for part 1 looks like this:\nfunc figureOutOrder(_ string: String) -\u003e String { var (dependencyDict, letterArray) = parseInput(string) var completedSet: Set = Set() var results: [String] = [] while letterArray.count \u003e 0 { for index in 0..","wordCount":"1792","inLanguage":"en","datePublished":"2018-12-08T00:00:00Z","dateModified":"2018-12-08T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://dillon-mce.com/posts/aoc2018/day7/"},"publisher":{"@type":"Organization","name":"Develop with Dillon","logo":{"@type":"ImageObject","url":"https://dillon-mce.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://dillon-mce.com accesskey=h title="Devlop with Dillon (Alt + H)"><img src=https://dillon-mce.com/apple-touch-icon.png alt=logo aria-label=logo height=35>Devlop with Dillon</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://dillon-mce.com/ title=Home><span>Home</span></a></li><li><a href=https://dillon-mce.com/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://dillon-mce.com/cv title=CV><span>CV</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Advent of Code 2018 - Day 7</h1><div class=post-meta><span title='2018-12-08 00:00:00 +0000 UTC'>December 8, 2018</span>&nbsp;·&nbsp;9 min&nbsp;|&nbsp;<a class=muted href=https://github.com/dillon-mce/dillon-mce.github.io/blob/main/content/posts/2018-12-08-Advent-of-Code-2018-Day-7.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><h2 id=problem-1httpsadventofcodecom2018day7><a href=https://adventofcode.com/2018/day/7>Problem 1</a><a hidden class=anchor aria-hidden=true href=#problem-1httpsadventofcodecom2018day7>#</a></h2><p>My understanding of Day 7’s first problem is this: given a series of instructions like the one below, return a String which is the correct order in which the instructions will be executed. The sample data returns <code>"CABDFE"</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>Step C must be finished before step A can begin.
</span></span><span style=display:flex><span>Step C must be finished before step F can begin.
</span></span><span style=display:flex><span>Step A must be finished before step B can begin.
</span></span><span style=display:flex><span>Step A must be finished before step D can begin.
</span></span><span style=display:flex><span>Step B must be finished before step E can begin.
</span></span><span style=display:flex><span>Step D must be finished before step E can begin.
</span></span><span style=display:flex><span>Step F must be finished before step E can begin.
</span></span></code></pre></div><h3 id=method>Method<a hidden class=anchor aria-hidden=true href=#method>#</a></h3><p>My method for solving this problem looks like this:</p><ul><li>Parse the input into a dictionary which holds steps that are dependent on others as the key and an array of the steps they are dependent as the value, and an array of all the steps that need to be executed, sorted alphabetically.</li><li>Make a set to hold the steps which are completed, and an array to hold the order all the steps in the order they are completed.</li><li>Using a similar method to <a href=https://dillon-mce.com/posts/aoc2018/day5/>the collapsing polymer problem</a>, loop through a while loop until the letter array is empty.<ul><li>Inside of that outer loop, loop through the array until a step that can be executed is found.</li><li>Execute that step. Insert it into the set of completed steps, append it to the results array, and remove it from the letter array.</li></ul></li><li>After the while loop, return the results array joined into a string.</li></ul><h3 id=implementation>Implementation<a hidden class=anchor aria-hidden=true href=#implementation>#</a></h3><p>My <code>parseInput()</code> function looks like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>parseInput</span>(<span style=color:#66d9ef>_</span> string: String) -&gt; ([String: [String]], [String]) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> array = string.components(separatedBy: .newlines))
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> dependencyDict: [String: [String]] = [:]
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> letterSet: Set&lt;String&gt; = Set()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> line <span style=color:#66d9ef>in</span> array {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> letters = line.components(separatedBy: .whitespaces).filter() { $0.count == <span style=color:#ae81ff>1</span> }
</span></span><span style=display:flex><span>        dependencyDict[letters[<span style=color:#ae81ff>1</span>], <span style=color:#66d9ef>default</span>: []].append(letters[<span style=color:#ae81ff>0</span>])
</span></span><span style=display:flex><span>        letterSet.insert(letters[<span style=color:#ae81ff>0</span>])
</span></span><span style=display:flex><span>        letterSet.insert(letters[<span style=color:#ae81ff>1</span>])
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> letterArray = Array(letterSet).sorted()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> (dependencyDict, letterArray)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>First, I break the string into an array split on newlines. Then I set up a dictionary to hold the steps that are dependent and an array of the steps they are dependent on and a set to hold all of the steps that need to be executed. Then I loop through each line in the array, break it up by splitting on whitespaces and filtering for single character elements. I add the dependency to the dependency dict and make sure both letters are in the letter set. At the end I make an array from the letter set, sort it, and then return a tuple of the dependency dictionary and a letter array.</p><p>My main function for part 1 looks like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>figureOutOrder</span>(<span style=color:#66d9ef>_</span> string: String) -&gt; String {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> (dependencyDict, letterArray) = parseInput(string)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> completedSet: Set&lt;String&gt; = Set()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> results: [String] = []
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> letterArray.count <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> index <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0.</span>.&lt;letterArray.count {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> letter = letterArray[index]
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> dependencies = dependencyDict[letter]?.filter() { <span style=color:#f92672>!</span>completedSet.contains($0) }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> dependencies == <span style=color:#66d9ef>nil</span> <span style=color:#f92672>||</span> dependencies == [] {
</span></span><span style=display:flex><span>                completedSet.insert(letter)
</span></span><span style=display:flex><span>                results.append(letter)
</span></span><span style=display:flex><span>                letterArray.remove(at: index)
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> results.joined()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>First, I get my dependency dictionary and letter array by calling <code>parseInput()</code> and set up variables to hold the completed steps and the resulting order. Then, inside a while loop that will continue until the letter array is empty, loop through the letter array until a letter is found that has no dependencies or, all of whose dependencies have been completed. Once one is found, I insert it into the completed set, add it to the results array, remove it from the letter array and break out of the current loop. Restarting from the beginning of the array every time a step is completed insures that if two steps could be completed at the same time, they will be completed in alphabetical order, as stipulated in the directions. Once the while loop completes, return the results array <code>.joined()</code></p><p>The answer for my input was <code>"CHILFNMORYKGAQXUVBZPSJWDET"</code> and it takes about 2 milliseconds to find using the command line method described in <a href=https://dillon-mce.com/posts/aoc2018/setup/>my AoC setup post</a>.</p><h2 id=problem-2httpsadventofcodecom2018day7part2><a href=https://adventofcode.com/2018/day/7#part2>Problem 2</a><a hidden class=anchor aria-hidden=true href=#problem-2httpsadventofcodecom2018day7part2>#</a></h2><p>I would describe the second problem like this: given the same set of instructions before, assuming that each step takes 60 seconds plus the letter’s index (e.g. A=61, B=62, Z=86) and assuming that there are up to five workers working on concurrent steps, return an Int which is how many seconds it will take to complete all the instructions.</p><h3 id=method-1>Method<a hidden class=anchor aria-hidden=true href=#method-1>#</a></h3><p>How I solved this problem:</p><ul><li>Write a helper function to build a dictionary of how long each step will take.</li><li>Add a custom Queue struct to represent a worker.<ul><li>Has a private array to hold its work</li><li>A computed property which is the step it is currently working on (optional)</li><li>A function to push a new step onto the queue, a given number of times</li><li>A function to pop an element off of the queue</li></ul></li><li>Use the same <code>parseInput()</code> method to get a dependency dictionary and letter array, use the helper function to get a dictionary of letter values, set up an array of Queues to hold the workers based on the number passed into the function, make a set to hold completed steps, a set to hold steps being worked on, and an Int variable to hold the resulting number of seconds.</li><li>Similar to part 1, make a while loop that will continue until the letter array is empty.</li><li>The while loop will have two sections, the first will cycle through the queues and complete one “second” of each of their work and update the letter array if any of them finish. The second part will loop through all the remaining letters, try to find one with no dependencies, and if there are any open queues, add it to that queue.</li><li>Each cycle through the while loop will add one second to the result “timer”</li></ul><h3 id=implementation-1>Implementation<a hidden class=anchor aria-hidden=true href=#implementation-1>#</a></h3><p>My helper function to set up the dictionary of letter values looks like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>setupLetterValueDictionary</span>(<span style=color:#66d9ef>_</span> offset: Int) -&gt; [String: Int] {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> alphabet = <span style=color:#e6db74>&#34;abcdefghijklmnopqrstuvwxyz&#34;</span>.uppercased()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> value = <span style=color:#ae81ff>1</span> <span style=color:#f92672>+</span> offset
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> result: [String: Int] = [:]
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> letter <span style=color:#66d9ef>in</span> alphabet {
</span></span><span style=display:flex><span>        result[String(letter)] = value
</span></span><span style=display:flex><span>        value <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> result
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Nothing very interesting, it just loops through the alphabet and adds the associated value to a dictionary at the key for each letter.</p><p>My custom Queue looks like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Queue</span>&lt;T&gt; {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>var</span> queue: [T] = []
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> currentlyWorkingOn: T? {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> queue.first
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>push</span>(<span style=color:#66d9ef>_</span> string: T, times: Int) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> <span style=color:#66d9ef>_</span> <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0.</span>.&lt;times {
</span></span><span style=display:flex><span>            queue.append(string)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>pop</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> queue.count <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>            queue.remove(at: <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>It is generic, mostly in case I need to reuse it in future code challenges. It has a private queue which is held in an array. It has a computed property which returns an optional element that is the first element of the queue or nil if it is empty. It has a function to push a new element onto the queue a given number of times, and it has a function to pop the first element off the queue. I did not return the element that is popped, because it isn’t necessary here.</p><p>The setup section of my main function looks like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>var</span> (dependencyDict, letterArray) = parseInput(string)
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> letterValueDict = setupLetterValueDictionary(timeAddition)
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> queues: [Queue&lt;String&gt;] = []
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> <span style=color:#66d9ef>_</span> <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0.</span>.&lt;numOfWorkers {
</span></span><span style=display:flex><span>    queues.append(Queue())
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> completedSet: Set&lt;String&gt; = Set()
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> currentlyWorkingOn: Set&lt;String&gt; = Set()
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> result: Int = <span style=color:#ae81ff>0</span>
</span></span></code></pre></div><p>I get the dependency dictionary and letter array by calling <code>parseInput()</code>, I get the letter values by calling <code>setupLetterValueDictionary()</code>, and I set up an array of queues to which I add as many queues as are called for when the function is called. I also make a set to hold the completed steps, a set to hold the steps that are being worked on, and a variable to hold the resulting number of seconds.</p><p>The first part of the while loop in the main function looks like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>while</span> letterArray.count <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> queue <span style=color:#66d9ef>in</span> queues {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> previouslyWorking = queue.currentlyWorkingOn
</span></span><span style=display:flex><span>            queue.pop()
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> previouslyWorking <span style=color:#f92672>!=</span> queue.currentlyWorkingOn {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> previouslyWorking = previouslyWorking {
</span></span><span style=display:flex><span>                    completedSet.insert(previouslyWorking)
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        letterArray = letterArray.filter() { <span style=color:#f92672>!</span>completedSet.contains( $0 ) }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> letterArray.count == <span style=color:#ae81ff>0</span> { <span style=color:#66d9ef>break</span> }
</span></span></code></pre></div><p>I loop through each queue, grab a reference to what it was working on, and then pop the first element. Then I check to see if the previous element is not the same as the current element. Because we are only adding one step to each queue at a time, we know that the only time they would be different is if we had some step in the queue and now we don’t. That means we’ve finished that step, so we’ll insert it into the set of completed letters. Then we filter the letter array to only have the letters that haven’t been completed and check to see if it is empty. If it is, that means we’re done and we break out of the loop.</p><p>The second half of the while loop looks like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span>    <span style=color:#66d9ef>for</span> letter <span style=color:#66d9ef>in</span> letterArray {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> dependencies = dependencyDict[letter]?.filter() { <span style=color:#f92672>!</span>completedSet.contains( $0 ) }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (dependencies == <span style=color:#66d9ef>nil</span> <span style=color:#f92672>||</span> dependencies == []) <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>currentlyWorkingOn.contains(letter) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>for</span> queue <span style=color:#66d9ef>in</span> queues {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> queue.currentlyWorkingOn == <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>let</span> times = letterValueDict[letter]<span style=color:#f92672>!</span>
</span></span><span style=display:flex><span>                        queue.push(letter, times: times)
</span></span><span style=display:flex><span>                        currentlyWorkingOn.insert(letter)
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        result <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>Here we first loop through the letters left in the letterArray, try to find one that doesn’t have any dependencies or all of whose dependencies have been completed, and that isn’t already being worked on by some other queue. If we find one, we’ll loop through all the queues and try to find one that isn’t already working on something. If we find one, we get the number of seconds that step will take to complete from the dictionary, push it onto the queue, insert it into the set of steps currently being worked on, and break out of this loop through the queues. At the end of each pass through the while loop, we add one to the resulting seconds. And after the while loop completes, return the result</p><p>The answer for my input is <code>891</code> with 5 workers and a 60 second offset. It takes about 45 milliseconds to calculate on the command line.</p><h2 id=reflections>Reflections<a hidden class=anchor aria-hidden=true href=#reflections>#</a></h2><ul><li>This problem gave me some good practice with using Sets and Dictionaries.</li><li>It also forced me to figure out a way to work out queues/concurrency with a possible different number of tasks being worked on at the same time.</li><li>It also gave me the opportunity to figure out how to simulate the passage of time.</li></ul><p>You can find all the code for my attempts so far in <a href=https://github.com/dillon-mce/advent-of-code-2018>my advent of code 2018 repository on GitHub</a>.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://dillon-mce.com/tags/advent-of-code/>Advent of Code</a></li></ul><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Advent of Code 2018 - Day 7 on twitter" href="https://twitter.com/intent/tweet/?text=Advent%20of%20Code%202018%20-%20Day%207&url=https%3a%2f%2fdillon-mce.com%2fposts%2faoc2018%2fday7%2f&hashtags=AdventofCode"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Advent of Code 2018 - Day 7 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fdillon-mce.com%2fposts%2faoc2018%2fday7%2f&title=Advent%20of%20Code%202018%20-%20Day%207&summary=Advent%20of%20Code%202018%20-%20Day%207&source=https%3a%2f%2fdillon-mce.com%2fposts%2faoc2018%2fday7%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Advent of Code 2018 - Day 7 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fdillon-mce.com%2fposts%2faoc2018%2fday7%2f&title=Advent%20of%20Code%202018%20-%20Day%207"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></div></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><footer class=footer><span>&copy; 2022 <a href=https://dillon-mce.com>Dillon McElhinney</a></span></footer><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>