<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Advent of Code 2018 - Day 5 | Develop with Dillon</title><meta name=keywords content="Advent of Code"><meta name=description content="Problem 1 My understanding of Day 5’s first problem is this: given a String like &#34;dabAcCaCBAcCcaDA&#34;, return an Int which is the number of characters remaining after being reduced by removing pairs of letters which are adjacent, the same letter, and opposite cases. For example &#34;cC&#34; and &#34;Aa&#34;. The sample returns 10.
Method My method for solving this problem looks like this:
 Make an outer while loop that will continue until you make it all the way through the String without finding any pairs that can be removed."><meta name=author content><link rel=canonical href=https://dillon-mce.com/posts/aoc2018/day5/><link crossorigin=anonymous href=/assets/css/stylesheet.min.ce635b481a80dcd7ff30654711f83610847e4ee919dae8042bd7839c9d7a0ffc.css integrity="sha256-zmNbSBqA3Nf/MGVHEfg2EIR+TukZ2ugEK9eDnJ16D/w=" rel="preload stylesheet" as=style><link rel=icon href=https://dillon-mce.com/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://dillon-mce.com/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://dillon-mce.com/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://dillon-mce.com/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://dillon-mce.com/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Advent of Code 2018 - Day 5"><meta property="og:description" content="Problem 1 My understanding of Day 5’s first problem is this: given a String like &#34;dabAcCaCBAcCcaDA&#34;, return an Int which is the number of characters remaining after being reduced by removing pairs of letters which are adjacent, the same letter, and opposite cases. For example &#34;cC&#34; and &#34;Aa&#34;. The sample returns 10.
Method My method for solving this problem looks like this:
 Make an outer while loop that will continue until you make it all the way through the String without finding any pairs that can be removed."><meta property="og:type" content="article"><meta property="og:url" content="https://dillon-mce.com/posts/aoc2018/day5/"><meta property="og:image" content="https://dillon-mce.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-12-06T00:00:00+00:00"><meta property="article:modified_time" content="2018-12-06T00:00:00+00:00"><meta property="og:site_name" content="Develop with Dillon"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://dillon-mce.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Advent of Code 2018 - Day 5"><meta name=twitter:description content="Problem 1 My understanding of Day 5’s first problem is this: given a String like &#34;dabAcCaCBAcCcaDA&#34;, return an Int which is the number of characters remaining after being reduced by removing pairs of letters which are adjacent, the same letter, and opposite cases. For example &#34;cC&#34; and &#34;Aa&#34;. The sample returns 10.
Method My method for solving this problem looks like this:
 Make an outer while loop that will continue until you make it all the way through the String without finding any pairs that can be removed."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://dillon-mce.com/posts/"},{"@type":"ListItem","position":3,"name":"Advent of Code 2018 - Day 5","item":"https://dillon-mce.com/posts/aoc2018/day5/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Advent of Code 2018 - Day 5","name":"Advent of Code 2018 - Day 5","description":"Problem 1 My understanding of Day 5’s first problem is this: given a String like \u0026quot;dabAcCaCBAcCcaDA\u0026quot;, return an Int which is the number of characters remaining after being reduced by removing pairs of letters which are adjacent, the same letter, and opposite cases. For example \u0026quot;cC\u0026quot; and \u0026quot;Aa\u0026quot;. The sample returns 10.\nMethod My method for solving this problem looks like this:\n Make an outer while loop that will continue until you make it all the way through the String without finding any pairs that can be removed.","keywords":["Advent of Code"],"articleBody":"Problem 1 My understanding of Day 5’s first problem is this: given a String like \"dabAcCaCBAcCcaDA\", return an Int which is the number of characters remaining after being reduced by removing pairs of letters which are adjacent, the same letter, and opposite cases. For example \"cC\" and \"Aa\". The sample returns 10.\nMethod My method for solving this problem looks like this:\n Make an outer while loop that will continue until you make it all the way through the String without finding any pairs that can be removed. Inside of the while loop, loop through all the letters in the String except the last, and check the current character against the next one. If the current letter doesn’t equal the next letter, but if the lowercased versions of each of them are equal, it means they meet the criteria for removal.  Remove them Update our start index for the next time through the for loop Break out of the current loop.   We need to check the letter before the ones we just removed, because it may have been affected by the removal. But we only need to go back one letter, we don’t need to check the whole preceding String again. If they don’t match and the current index equals the second to last element, that means we have made it all the way through the String successfully, so update that Bool and end the while loop. Finally, return the resulting String.  Implementation My collapsePolymer() function for the first part looks like this:\nfunc collapsePolymer(_ string: String) - String {  var array = Array(string)  var madeFullPass = false  var madeToIndex = 0   while !madeFullPass {  for i in madeToIndex..- 1 {  let firstLetter = String(array[i])  let secondLetter = String(array[i+1])  if firstLetter.lowercased() == secondLetter.lowercased() \u0026\u0026 firstLetter != secondLetter {  array.remove(at: i)  array.remove(at: i)  madeToIndex = i  1 ? i - 2 : 0  break  } else if i == array.count-2 {  madeFullPass = true  }  }  }  return String(array) } First, I get an array of the string, so I can loop through it easily and set up helper variables to keep track of whether I have made a full pass yet, and what index I have checked up to so far. Then I make a while loop that will continue until I’ve made a full pass. In side of that, I make a for loop that starts at the index I’ve made it too that I’m sure doesn’t need to be checked again and goes up to the array’s count minus one. Since we’re removing elements, that count is constantly changing, which is why it is necessary to break out of the loop every time we remove elements.\nI get references to the letters I want to check, I make them strings so I can call .lowercased() on them, and then I have a two part test. If they are equal when they are both lowercased, but not equal when they are not, that means they are the same letter, but different cases, which is the criteria we’re looking for. If they meet that criteria, I remove both of them from the array, update the index I’ve made it to so far, and then break out of the current loop. If they don’t meet that criteria, but the index does equal the second to last index in the array, we’ve made a full pass.\nI didn’t originally keep track of the index I have made it to, but it was taking too long, so I added that as a limit to how many times we’d need to run through all of the for loop. It is necessary because of the length of the data and the fact that I am restarting the for loop every time I remove a letter (which happens a lot). Part 1 takes about 0.2 seconds when keeping track of the index, and about 30 seconds when starting the for loop over at 0 every time, meaning it goes about 150 times faster when you make those few simple changes.\nI also made the function return a String because it was easier to troubleshoot while I was writing the code. Then I got the real answer by calling .count on the String given back to me.\nThe answer for my input was 11720 and it takes about 0.2 seconds to calculate when running on the command line as described in my AoC Setup post.\nProblem 2 I would describe the second problem like this: given the same String as before, return an Int which is the length of the String after all reductions, after removing all of one letter (both cases). The sample data returns 4, which is produced after removing all the c/C's\nMethod This is how I solved this problem:\n Get a set of all the letters contained in the String (hint: it was all 26 of them.) Make a dictionary to hold the result after the removal of each letter. For each letter in the set, filter out that letter and then call collapsePolymer() on it. Store the result in the dictionary After all the letters have been checked, find the smallest resulting value and return it.  Implementation Here is my function to solve part 2:\nfunc testWithoutCertainLetters(_ string: String) - Int {  let letters = Set(Array(string.lowercased()))  var resultsDict: [Character: String] = [:]   for letter in letters {  let array = Array(string).filter() { String($0).lowercased() != String(letter) }  let result = collapsePolymer(String(array))  resultsDict[letter] = result  }   let answer = resultsDict.min(by: { $0.value.count  $1.value.count })  return answer?.value.count ?? -1 } First, I make a Set out of an Array that is made from the input String that has been lowercased. This gives me a set of each letter that is used in the String to check against. Then I make a dictionary of Characters and Strings, to hold the results after removing each letter.\nThen I cycle through the letters, remove them from the String and call collapsePolymer() on it. I store the result in the dictionary with that letter as the key. At the end, I return the smallest result’s count.\nIt was only really necessary to keep them in a dictionary because I was curious what the spread looked like with removing each letter and that the winning letter was. Turns out, there wasn’t a lot of variance except with the winning letter. With my input, removing every letter except \"w\" resulted in a polymer between 11,000 and 11,999 characters long. Removing \"w\" resulted in the answer of 4956. The whole thing takes about 4 seconds to calculate, running on the command line.\nReflections  This problem forced me to think of creative ways to limit the scope of the function to only what we cared about. It also gave me the opportunity to discover this double-loop technique where you keep looping through the outer loop until you make it all the way through the inner loop, and the inner loop keeps restarting every time an element is removed. That technique, paired with keeping track of where you need to restart the inner loop, becomes a fairly efficient way to cycle through the data and compress it. I could imagine a similar technique being used to compress an image or audio file.  You can find all the code for my attempts so far in my advent of code 2018 repository on GitHub.\n","wordCount":"1231","inLanguage":"en","datePublished":"2018-12-06T00:00:00Z","dateModified":"2018-12-06T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://dillon-mce.com/posts/aoc2018/day5/"},"publisher":{"@type":"Organization","name":"Develop with Dillon","logo":{"@type":"ImageObject","url":"https://dillon-mce.com/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://dillon-mce.com accesskey=h title="Devlop with Dillon (Alt + H)"><img src=https://dillon-mce.com/apple-touch-icon.png alt=logo aria-label=logo height=35>Devlop with Dillon</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://dillon-mce.com/ title=Home><span>Home</span></a></li><li><a href=https://dillon-mce.com/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://dillon-mce.com/cv title=CV><span>CV</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Advent of Code 2018 - Day 5</h1><div class=post-meta><span title="2018-12-06 00:00:00 +0000 UTC">December 6, 2018</span>&nbsp;·&nbsp;6 min&nbsp;|&nbsp;<a class=muted href=https://github.com/dillon-mce/dillon-mce.github.io/content/posts/2018-12-06-Advent-of-Code-2018-Day-5.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><h2 id=problem-1httpsadventofcodecom2018day5><a href=https://adventofcode.com/2018/day/5>Problem 1</a><a hidden class=anchor aria-hidden=true href=#problem-1httpsadventofcodecom2018day5>#</a></h2><p>My understanding of Day 5’s first problem is this: given a String like <code>"dabAcCaCBAcCcaDA"</code>, return an Int which is the number of characters remaining after being reduced by removing pairs of letters which are adjacent, the same letter, and opposite cases. For example <code>"cC"</code> and <code>"Aa"</code>. The sample returns 10.</p><h3 id=method>Method<a hidden class=anchor aria-hidden=true href=#method>#</a></h3><p>My method for solving this problem looks like this:</p><ul><li>Make an outer while loop that will continue until you make it all the way through the String without finding any pairs that can be removed.</li><li>Inside of the while loop, loop through all the letters in the String except the last, and check the current character against the next one.</li><li>If the current letter doesn’t equal the next letter, but if the lowercased versions of each of them are equal, it means they meet the criteria for removal.<ul><li>Remove them</li><li>Update our start index for the next time through the for loop</li><li>Break out of the current loop.</li></ul></li><li>We need to check the letter before the ones we just removed, because it may have been affected by the removal. But we only need to go back one letter, we don’t need to check the whole preceding String again.</li><li>If they don’t match and the current index equals the second to last element, that means we have made it all the way through the String successfully, so update that Bool and end the while loop.</li><li>Finally, return the resulting String.</li></ul><h3 id=implementation>Implementation<a hidden class=anchor aria-hidden=true href=#implementation>#</a></h3><p>My <code>collapsePolymer()</code> function for the first part looks like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>collapsePolymer</span>(<span style=color:#66d9ef>_</span> string: String) -&gt; String {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> array = Array(string)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> madeFullPass = <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> madeToIndex = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> <span style=color:#f92672>!</span>madeFullPass {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> i <span style=color:#66d9ef>in</span> madeToIndex..&lt;array.count <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> firstLetter = String(array[i])
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> secondLetter = String(array[i<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>])
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> firstLetter.lowercased() == secondLetter.lowercased() <span style=color:#f92672>&amp;&amp;</span> firstLetter <span style=color:#f92672>!=</span> secondLetter {
</span></span><span style=display:flex><span>                array.remove(at: i)
</span></span><span style=display:flex><span>                array.remove(at: i)
</span></span><span style=display:flex><span>                madeToIndex = i <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>1</span> ? i <span style=color:#f92672>-</span> <span style=color:#ae81ff>2</span> : <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> i == array.count<span style=color:#f92672>-</span><span style=color:#ae81ff>2</span> {
</span></span><span style=display:flex><span>                madeFullPass = <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> String(array)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>First, I get an array of the string, so I can loop through it easily and set up helper variables to keep track of whether I have made a full pass yet, and what index I have checked up to so far. Then I make a while loop that will continue until I’ve made a full pass. In side of that, I make a for loop that starts at the index I’ve made it too that I’m sure doesn’t need to be checked again and goes up to the array’s count minus one. Since we’re removing elements, that count is constantly changing, which is why it is necessary to break out of the loop every time we remove elements.</p><p>I get references to the letters I want to check, I make them strings so I can call <code>.lowercased()</code> on them, and then I have a two part test. If they are equal when they are both lowercased, but not equal when they are not, that means they are the same letter, but different cases, which is the criteria we’re looking for. If they meet that criteria, I remove both of them from the array, update the index I’ve made it to so far, and then break out of the current loop. If they don’t meet that criteria, but the index does equal the second to last index in the array, we’ve made a full pass.</p><p>I didn’t originally keep track of the index I have made it to, but it was taking too long, so I added that as a limit to how many times we’d need to run through all of the for loop. It is necessary because of the length of the data and the fact that I am restarting the for loop every time I remove a letter (which happens a lot). Part 1 takes about 0.2 seconds when keeping track of the index, and about 30 seconds when starting the for loop over at 0 every time, meaning it goes about 150 times faster when you make those few simple changes.</p><p>I also made the function return a String because it was easier to troubleshoot while I was writing the code. Then I got the real answer by calling <code>.count</code> on the String given back to me.</p><p>The answer for my input was <code>11720</code> and it takes about 0.2 seconds to calculate when running on the command line as described in <a href=https://dillon-mce.com/posts/aoc2018/setup/>my AoC Setup post</a>.</p><h2 id=problem-2httpsadventofcodecom2018day5part2><a href=https://adventofcode.com/2018/day/5#part2>Problem 2</a><a hidden class=anchor aria-hidden=true href=#problem-2httpsadventofcodecom2018day5part2>#</a></h2><p>I would describe the second problem like this: given the same String as before, return an Int which is the length of the String after all reductions, after removing all of one letter (both cases). The sample data returns 4, which is produced after removing all the <code>c/C's</code></p><h3 id=method-1>Method<a hidden class=anchor aria-hidden=true href=#method-1>#</a></h3><p>This is how I solved this problem:</p><ul><li>Get a set of all the letters contained in the String (hint: it was all 26 of them.)</li><li>Make a dictionary to hold the result after the removal of each letter.</li><li>For each letter in the set, filter out that letter and then call <code>collapsePolymer()</code> on it.</li><li>Store the result in the dictionary</li><li>After all the letters have been checked, find the smallest resulting value and return it.</li></ul><h3 id=implementation-1>Implementation<a hidden class=anchor aria-hidden=true href=#implementation-1>#</a></h3><p>Here is my function to solve part 2:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>testWithoutCertainLetters</span>(<span style=color:#66d9ef>_</span> string: String) -&gt; Int {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> letters = Set(Array(string.lowercased()))
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> resultsDict: [Character: String] = [:]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> letter <span style=color:#66d9ef>in</span> letters {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> array = Array(string).filter() { String($0).lowercased() <span style=color:#f92672>!=</span> String(letter) }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> result = collapsePolymer(String(array))
</span></span><span style=display:flex><span>        resultsDict[letter] = result
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> answer = resultsDict.min(by: { $0.value.count <span style=color:#f92672>&lt;</span> $1.value.count })
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> answer?.value.count ?? <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>First, I make a Set out of an Array that is made from the input String that has been lowercased. This gives me a set of each letter that is used in the String to check against. Then I make a dictionary of Characters and Strings, to hold the results after removing each letter.</p><p>Then I cycle through the letters, remove them from the String and call <code>collapsePolymer()</code> on it. I store the result in the dictionary with that letter as the key. At the end, I return the smallest result’s count.</p><p>It was only really necessary to keep them in a dictionary because I was curious what the spread looked like with removing each letter and that the winning letter was. Turns out, there wasn’t a lot of variance except with the winning letter. With my input, removing every letter except <code>"w"</code> resulted in a polymer between 11,000 and 11,999 characters long. Removing <code>"w"</code> resulted in the answer of <code>4956</code>. The whole thing takes about 4 seconds to calculate, running on the command line.</p><h2 id=reflections>Reflections<a hidden class=anchor aria-hidden=true href=#reflections>#</a></h2><ul><li>This problem forced me to think of creative ways to limit the scope of the function to only what we cared about.</li><li>It also gave me the opportunity to discover this double-loop technique where you keep looping through the outer loop until you make it all the way through the inner loop, and the inner loop keeps restarting every time an element is removed. That technique, paired with keeping track of where you need to restart the inner loop, becomes a fairly efficient way to cycle through the data and compress it. I could imagine a similar technique being used to compress an image or audio file.</li></ul><p>You can find all the code for my attempts so far in <a href=https://github.com/dillon-mce/advent-of-code-2018>my advent of code 2018 repository on GitHub</a>.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://dillon-mce.com/tags/advent-of-code/>Advent of Code</a></li></ul><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Advent of Code 2018 - Day 5 on twitter" href="https://twitter.com/intent/tweet/?text=Advent%20of%20Code%202018%20-%20Day%205&url=https%3a%2f%2fdillon-mce.com%2fposts%2faoc2018%2fday5%2f&hashtags=AdventofCode"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Advent of Code 2018 - Day 5 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fdillon-mce.com%2fposts%2faoc2018%2fday5%2f&title=Advent%20of%20Code%202018%20-%20Day%205&summary=Advent%20of%20Code%202018%20-%20Day%205&source=https%3a%2f%2fdillon-mce.com%2fposts%2faoc2018%2fday5%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Advent of Code 2018 - Day 5 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fdillon-mce.com%2fposts%2faoc2018%2fday5%2f&title=Advent%20of%20Code%202018%20-%20Day%205"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></div></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><footer class=footer><span>&copy; 2022 <a href=https://dillon-mce.com>Dillon McElhinney</a></span></footer><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(t=>{const n=t.parentNode.parentNode,e=document.createElement("button");e.classList.add("copy-code"),e.innerHTML="copy";function s(){e.innerHTML="copied!",setTimeout(()=>{e.innerHTML="copy"},2e3)}e.addEventListener("click",o=>{if("clipboard"in navigator){navigator.clipboard.writeText(t.textContent),s();return}const e=document.createRange();e.selectNodeContents(t);const n=window.getSelection();n.removeAllRanges(),n.addRange(e);try{document.execCommand("copy"),s()}catch(e){}n.removeRange(e)}),n.classList.contains("highlight")?n.appendChild(e):n.parentNode.firstChild==n||(t.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?t.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(e):t.parentNode.appendChild(e))})</script></body></html>